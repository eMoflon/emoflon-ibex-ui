/*
 * generated by Xtext
 */
package org.moflon.tgg.mosl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.moflon.tgg.mosl.services.TGGGrammarAccess;
import org.moflon.tgg.mosl.tgg.Adornment;
import org.moflon.tgg.mosl.tgg.AttrCond;
import org.moflon.tgg.mosl.tgg.AttrCondDef;
import org.moflon.tgg.mosl.tgg.AttrCondDefLibrary;
import org.moflon.tgg.mosl.tgg.AttributeAssignment;
import org.moflon.tgg.mosl.tgg.AttributeConstraint;
import org.moflon.tgg.mosl.tgg.AttributeExpression;
import org.moflon.tgg.mosl.tgg.ContextLinkVariablePattern;
import org.moflon.tgg.mosl.tgg.ContextObjectVariablePattern;
import org.moflon.tgg.mosl.tgg.CorrType;
import org.moflon.tgg.mosl.tgg.CorrVariablePattern;
import org.moflon.tgg.mosl.tgg.EnumExpression;
import org.moflon.tgg.mosl.tgg.Import;
import org.moflon.tgg.mosl.tgg.LinkVariablePattern;
import org.moflon.tgg.mosl.tgg.LiteralExpression;
import org.moflon.tgg.mosl.tgg.LocalVariable;
import org.moflon.tgg.mosl.tgg.Nac;
import org.moflon.tgg.mosl.tgg.ObjectVariablePattern;
import org.moflon.tgg.mosl.tgg.Operator;
import org.moflon.tgg.mosl.tgg.Param;
import org.moflon.tgg.mosl.tgg.Rule;
import org.moflon.tgg.mosl.tgg.Schema;
import org.moflon.tgg.mosl.tgg.TggPackage;
import org.moflon.tgg.mosl.tgg.TripleGraphGrammarFile;
import org.moflon.tgg.mosl.tgg.Using;

@SuppressWarnings("all")
public class TGGSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private TGGGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == TggPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TggPackage.ADORNMENT:
				sequence_Adornment(context, (Adornment) semanticObject); 
				return; 
			case TggPackage.ATTR_COND:
				sequence_AttrCond(context, (AttrCond) semanticObject); 
				return; 
			case TggPackage.ATTR_COND_DEF:
				sequence_AttrCondDef(context, (AttrCondDef) semanticObject); 
				return; 
			case TggPackage.ATTR_COND_DEF_LIBRARY:
				sequence_AttrCondDefLibrary(context, (AttrCondDefLibrary) semanticObject); 
				return; 
			case TggPackage.ATTRIBUTE_ASSIGNMENT:
				sequence_AttributeAssignment(context, (AttributeAssignment) semanticObject); 
				return; 
			case TggPackage.ATTRIBUTE_CONSTRAINT:
				sequence_AttributeConstraint(context, (AttributeConstraint) semanticObject); 
				return; 
			case TggPackage.ATTRIBUTE_EXPRESSION:
				sequence_AttributeExpression(context, (AttributeExpression) semanticObject); 
				return; 
			case TggPackage.CONTEXT_LINK_VARIABLE_PATTERN:
				sequence_ContextLinkVariablePattern(context, (ContextLinkVariablePattern) semanticObject); 
				return; 
			case TggPackage.CONTEXT_OBJECT_VARIABLE_PATTERN:
				sequence_ContextObjectVariablePattern(context, (ContextObjectVariablePattern) semanticObject); 
				return; 
			case TggPackage.CORR_TYPE:
				sequence_CorrType(context, (CorrType) semanticObject); 
				return; 
			case TggPackage.CORR_VARIABLE_PATTERN:
				sequence_CorrVariablePattern(context, (CorrVariablePattern) semanticObject); 
				return; 
			case TggPackage.ENUM_EXPRESSION:
				sequence_EnumExpression(context, (EnumExpression) semanticObject); 
				return; 
			case TggPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case TggPackage.LINK_VARIABLE_PATTERN:
				sequence_LinkVariablePattern(context, (LinkVariablePattern) semanticObject); 
				return; 
			case TggPackage.LITERAL_EXPRESSION:
				sequence_LiteralExpression(context, (LiteralExpression) semanticObject); 
				return; 
			case TggPackage.LOCAL_VARIABLE:
				sequence_LocalVariable(context, (LocalVariable) semanticObject); 
				return; 
			case TggPackage.NAC:
				sequence_Nac(context, (Nac) semanticObject); 
				return; 
			case TggPackage.OBJECT_VARIABLE_PATTERN:
				sequence_ObjectVariablePattern(context, (ObjectVariablePattern) semanticObject); 
				return; 
			case TggPackage.OPERATOR:
				sequence_Operator(context, (Operator) semanticObject); 
				return; 
			case TggPackage.PARAM:
				sequence_Param(context, (Param) semanticObject); 
				return; 
			case TggPackage.RULE:
				sequence_Rule(context, (Rule) semanticObject); 
				return; 
			case TggPackage.SCHEMA:
				sequence_Schema(context, (Schema) semanticObject); 
				return; 
			case TggPackage.TRIPLE_GRAPH_GRAMMAR_FILE:
				sequence_TripleGraphGrammarFile(context, (TripleGraphGrammarFile) semanticObject); 
				return; 
			case TggPackage.USING:
				sequence_Using(context, (Using) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Adornment returns Adornment
	 *
	 * Constraint:
	 *     (value+='B' | value+='F')+
	 */
	protected void sequence_Adornment(ISerializationContext context, Adornment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttrCondDefLibrary returns AttrCondDefLibrary
	 *     NamedElements returns AttrCondDefLibrary
	 *
	 * Constraint:
	 *     (name=QualifiedName attributeCondDefs+=AttrCondDef*)
	 */
	protected void sequence_AttrCondDefLibrary(ISerializationContext context, AttrCondDefLibrary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttrCondDef returns AttrCondDef
	 *     NamedElements returns AttrCondDef
	 *
	 * Constraint:
	 *     (
	 *         userDefined?='#userDefined'? 
	 *         name=ID 
	 *         (params+=Param params+=Param*)? 
	 *         allowedSyncAdornments+=Adornment 
	 *         allowedSyncAdornments+=Adornment* 
	 *         (allowedGenAdornments+=Adornment allowedGenAdornments+=Adornment*)?
	 *     )
	 */
	protected void sequence_AttrCondDef(ISerializationContext context, AttrCondDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttrCond returns AttrCond
	 *
	 * Constraint:
	 *     (name=[AttrCondDef|ID] (values+=ParamValue values+=ParamValue*)?)
	 */
	protected void sequence_AttrCond(ISerializationContext context, AttrCond semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributeAssignment returns AttributeAssignment
	 *
	 * Constraint:
	 *     (attribute=[EAttribute|ID] op=':=' valueExp=Expression)
	 */
	protected void sequence_AttributeAssignment(ISerializationContext context, AttributeAssignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TggPackage.Literals.ATTRIBUTE_ASSIGNMENT__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TggPackage.Literals.ATTRIBUTE_ASSIGNMENT__ATTRIBUTE));
			if (transientValues.isValueTransient(semanticObject, TggPackage.Literals.ATTRIBUTE_ASSIGNMENT__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TggPackage.Literals.ATTRIBUTE_ASSIGNMENT__OP));
			if (transientValues.isValueTransient(semanticObject, TggPackage.Literals.ATTRIBUTE_ASSIGNMENT__VALUE_EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TggPackage.Literals.ATTRIBUTE_ASSIGNMENT__VALUE_EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeAssignmentAccess().getAttributeEAttributeIDTerminalRuleCall_0_0_1(), semanticObject.eGet(TggPackage.Literals.ATTRIBUTE_ASSIGNMENT__ATTRIBUTE, false));
		feeder.accept(grammarAccess.getAttributeAssignmentAccess().getOpColonEqualsSignKeyword_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getAttributeAssignmentAccess().getValueExpExpressionParserRuleCall_2_0(), semanticObject.getValueExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AttributeConstraint returns AttributeConstraint
	 *
	 * Constraint:
	 *     (
	 *         attribute=[EAttribute|ID] 
	 *         (
	 *             op='==' | 
	 *             op='!=' | 
	 *             op='<=' | 
	 *             op='>=' | 
	 *             op='>' | 
	 *             op='<'
	 *         ) 
	 *         valueExp=Expression
	 *     )
	 */
	protected void sequence_AttributeConstraint(ISerializationContext context, AttributeConstraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParamValue returns AttributeExpression
	 *     Expression returns AttributeExpression
	 *     AttributeExpression returns AttributeExpression
	 *
	 * Constraint:
	 *     (derived?='#derived'? objectVar=[EObject|ID] attribute=[EAttribute|ID])
	 */
	protected void sequence_AttributeExpression(ISerializationContext context, AttributeExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContextLinkVariablePattern returns ContextLinkVariablePattern
	 *
	 * Constraint:
	 *     (type=[EReference|ID] target=[ContextObjectVariablePattern|ID])
	 */
	protected void sequence_ContextLinkVariablePattern(ISerializationContext context, ContextLinkVariablePattern semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TggPackage.Literals.CONTEXT_LINK_VARIABLE_PATTERN__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TggPackage.Literals.CONTEXT_LINK_VARIABLE_PATTERN__TYPE));
			if (transientValues.isValueTransient(semanticObject, TggPackage.Literals.CONTEXT_LINK_VARIABLE_PATTERN__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TggPackage.Literals.CONTEXT_LINK_VARIABLE_PATTERN__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getContextLinkVariablePatternAccess().getTypeEReferenceIDTerminalRuleCall_1_0_1(), semanticObject.eGet(TggPackage.Literals.CONTEXT_LINK_VARIABLE_PATTERN__TYPE, false));
		feeder.accept(grammarAccess.getContextLinkVariablePatternAccess().getTargetContextObjectVariablePatternIDTerminalRuleCall_3_0_1(), semanticObject.eGet(TggPackage.Literals.CONTEXT_LINK_VARIABLE_PATTERN__TARGET, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ContextObjectVariablePattern returns ContextObjectVariablePattern
	 *
	 * Constraint:
	 *     (name=ID type=[EClass|QualifiedName] attributeConstraints+=AttributeConstraint* linkVariablePatterns+=ContextLinkVariablePattern*)
	 */
	protected void sequence_ContextObjectVariablePattern(ISerializationContext context, ContextObjectVariablePattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CorrType returns CorrType
	 *     NamedElements returns CorrType
	 *
	 * Constraint:
	 *     (name=ID (super=[CorrType|ID] | (source=[EClass|QualifiedName] target=[EClass|QualifiedName])))
	 */
	protected void sequence_CorrType(ISerializationContext context, CorrType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CorrVariablePattern returns CorrVariablePattern
	 *     OperatorPattern returns CorrVariablePattern
	 *     NamedElements returns CorrVariablePattern
	 *     NamePattern returns CorrVariablePattern
	 *
	 * Constraint:
	 *     (op=Operator? name=ID type=[CorrType|QualifiedName] source=[ObjectVariablePattern|ID] target=[ObjectVariablePattern|ID])
	 */
	protected void sequence_CorrVariablePattern(ISerializationContext context, CorrVariablePattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParamValue returns EnumExpression
	 *     Expression returns EnumExpression
	 *     EnumExpression returns EnumExpression
	 *
	 * Constraint:
	 *     (eenum=[EEnum|QualifiedName] literal=[EEnumLiteral|QualifiedName])
	 */
	protected void sequence_EnumExpression(ISerializationContext context, EnumExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TggPackage.Literals.ENUM_EXPRESSION__EENUM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TggPackage.Literals.ENUM_EXPRESSION__EENUM));
			if (transientValues.isValueTransient(semanticObject, TggPackage.Literals.ENUM_EXPRESSION__LITERAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TggPackage.Literals.ENUM_EXPRESSION__LITERAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumExpressionAccess().getEenumEEnumQualifiedNameParserRuleCall_1_0_1(), semanticObject.eGet(TggPackage.Literals.ENUM_EXPRESSION__EENUM, false));
		feeder.accept(grammarAccess.getEnumExpressionAccess().getLiteralEEnumLiteralQualifiedNameParserRuleCall_3_0_1(), semanticObject.eGet(TggPackage.Literals.ENUM_EXPRESSION__LITERAL, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     name=STRING
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TggPackage.Literals.IMPORT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TggPackage.Literals.IMPORT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LinkVariablePattern returns LinkVariablePattern
	 *     OperatorPattern returns LinkVariablePattern
	 *
	 * Constraint:
	 *     (op=Operator? type=[EReference|ID] target=[ObjectVariablePattern|ID])
	 */
	protected void sequence_LinkVariablePattern(ISerializationContext context, LinkVariablePattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParamValue returns LiteralExpression
	 *     Expression returns LiteralExpression
	 *     LiteralExpression returns LiteralExpression
	 *
	 * Constraint:
	 *     value=LiteralValue
	 */
	protected void sequence_LiteralExpression(ISerializationContext context, LiteralExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TggPackage.Literals.LITERAL_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TggPackage.Literals.LITERAL_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralExpressionAccess().getValueLiteralValueParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ParamValue returns LocalVariable
	 *     LocalVariable returns LocalVariable
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_LocalVariable(ISerializationContext context, LocalVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TggPackage.Literals.LOCAL_VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TggPackage.Literals.LOCAL_VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLocalVariableAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Nac returns Nac
	 *     NamedElements returns Nac
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         rule=[Rule|ID] 
	 *         (sourcePatterns+=ContextObjectVariablePattern+ | targetPatterns+=ContextObjectVariablePattern+)? 
	 *         attrConditions+=AttrCond*
	 *     )
	 */
	protected void sequence_Nac(ISerializationContext context, Nac semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ObjectVariablePattern returns ObjectVariablePattern
	 *     OperatorPattern returns ObjectVariablePattern
	 *     NamedElements returns ObjectVariablePattern
	 *     NamePattern returns ObjectVariablePattern
	 *
	 * Constraint:
	 *     (
	 *         op=Operator? 
	 *         name=ID 
	 *         type=[EClass|QualifiedName] 
	 *         attributeAssignments+=AttributeAssignment* 
	 *         attributeConstraints+=AttributeConstraint* 
	 *         linkVariablePatterns+=LinkVariablePattern*
	 *     )
	 */
	protected void sequence_ObjectVariablePattern(ISerializationContext context, ObjectVariablePattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operator returns Operator
	 *
	 * Constraint:
	 *     value='++'
	 */
	protected void sequence_Operator(ISerializationContext context, Operator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TggPackage.Literals.OPERATOR__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TggPackage.Literals.OPERATOR__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOperatorAccess().getValuePlusSignPlusSignKeyword_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Param returns Param
	 *
	 * Constraint:
	 *     (paramName=ID type=[EDataType|QualifiedName])
	 */
	protected void sequence_Param(ISerializationContext context, Param semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TggPackage.Literals.PARAM__PARAM_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TggPackage.Literals.PARAM__PARAM_NAME));
			if (transientValues.isValueTransient(semanticObject, TggPackage.Literals.PARAM__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TggPackage.Literals.PARAM__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParamAccess().getParamNameIDTerminalRuleCall_0_0(), semanticObject.getParamName());
		feeder.accept(grammarAccess.getParamAccess().getTypeEDataTypeQualifiedNameParserRuleCall_2_0_1(), semanticObject.eGet(TggPackage.Literals.PARAM__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns Rule
	 *     NamedElements returns Rule
	 *
	 * Constraint:
	 *     (
	 *         abstractRule?='#abstract'? 
	 *         name=ID 
	 *         (supertypes+=[Rule|ID] supertypes+=[Rule|ID]*)? 
	 *         schema=[Schema|QualifiedName] 
	 *         sourcePatterns+=ObjectVariablePattern* 
	 *         targetPatterns+=ObjectVariablePattern* 
	 *         correspondencePatterns+=CorrVariablePattern* 
	 *         attrConditions+=AttrCond*
	 *     )
	 */
	protected void sequence_Rule(ISerializationContext context, Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Schema returns Schema
	 *     NamedElements returns Schema
	 *
	 * Constraint:
	 *     (
	 *         name=QualifiedName 
	 *         sourceTypes+=[EPackage|QualifiedName]* 
	 *         targetTypes+=[EPackage|QualifiedName]* 
	 *         correspondenceTypes+=CorrType* 
	 *         attributeCondDefs+=AttrCondDef*
	 *     )
	 */
	protected void sequence_Schema(ISerializationContext context, Schema semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TripleGraphGrammarFile returns TripleGraphGrammarFile
	 *
	 * Constraint:
	 *     (
	 *         (imports+=Import+ ((schema=Schema library=AttrCondDefLibrary) | library=AttrCondDefLibrary)) | 
	 *         (((imports+=Import+ using+=Using+) | using+=Using+) ((schema=Schema library=AttrCondDefLibrary) | library=AttrCondDefLibrary)) | 
	 *         (
	 *             ((imports+=Import+ ((using+=Using+ schema=Schema) | schema=Schema)) | (using+=Using+ schema=Schema) | schema=Schema)? 
	 *             rules+=Rule+ 
	 *             library=AttrCondDefLibrary
	 *         ) | 
	 *         (schema=Schema library=AttrCondDefLibrary) | 
	 *         library=AttrCondDefLibrary
	 *     )?
	 */
	protected void sequence_TripleGraphGrammarFile(ISerializationContext context, TripleGraphGrammarFile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Using returns Using
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_Using(ISerializationContext context, Using semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TggPackage.Literals.USING__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TggPackage.Literals.USING__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUsingAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
}
