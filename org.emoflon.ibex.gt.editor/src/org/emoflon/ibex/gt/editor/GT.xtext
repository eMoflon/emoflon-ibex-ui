grammar org.emoflon.ibex.gt.editor.GT with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate gT "http://www.emoflon.org/ibex/gt/editor/GT"

EditorGTFile:
  (imports+=EditorImport)*
  (patterns+=EditorPattern |
  conditions+=EditorCondition |
  attributeConditionLibraries+=EditorAttributeConditionLibrary)*;

EditorImport:
  'import' name=STRING;

EditorPattern:
  (abstract?='abstract')? type=EditorPatternType name=ID
  ('('
  (parameters+=EditorParameter (',' parameters+=EditorParameter)*)?
  ')')?
  ('refines' superPatterns+=[EditorPattern] (',' superPatterns+=[EditorPattern])*)?
  ('{'
  (nodes+=EditorNode | complexAttributeConstraints+=EditorPatternAttributeCondition)*
  '}')?
  ('when' conditions+=[EditorCondition] ('||' conditions+=[EditorCondition])*)?
  (stochastic ?='@' probability = EditorProbability)?;

EditorPatternElement:
  EditorNode | EditorPatternAttributeCondition;

enum EditorPatternType:
  PATTERN='pattern' |
  RULE='rule';

EditorParameter:
  name=ID ':' type=[ecore::EDataType];

  // Nodes
EditorNode:
  (operator=OperatorInEditor)?
  name=ID ':' type=[ecore::EClass] (binding=EditorBindingExpression)?
  ('{'
  attributes+=EditorAttribute*
  references+=EditorReference*
  attributeConditions+=EditorPatternAttributeCondition*
  '}')?;

enum EditorOperator:
  CONTEXT |
  CREATE |
  DELETE;

enum OperatorInEditor returns EditorOperator:
  CREATE='++' |
  DELETE='--';

  // Attribute Assignments and Conditions
EditorAttribute:
  '.' attribute=[ecore::EAttribute] relation=EditorRelation value=EditorExpression;

enum EditorRelation:
  ASSIGNMENT=':=' |
  GREATER='>' |
  GREATER_OR_EQUAL='>=' |
  EQUAL='==' |
  UNEQUAL='!=' |
  SMALLER_OR_EQUAL='<=' |
  SMALLER='<';

EditorExpression:
  EditorAttributeExpression | EditorLiteralExpression | EditorEnumExpression | EditorCountExpression |
  EditorParameterExpression | StochasticFunctionExpression | ArithmeticCalculationExpression;

EditorAttributeExpression:
  node=[EditorNode] '.' attribute=[ecore::EAttribute];
  
EditorCountExpression:
	'count' '(' invokedPatten = [EditorPattern] ')'
;

EditorLiteralExpression:
  value=('true' | 'false' | Number) |
  {StringConstant} value=STRING;

Number:
  ('-')? INT ('.' INT)?;

EditorEnumExpression:
  'enum::' literal=[ecore::EEnumLiteral];

EditorParameterExpression:
  'param::' parameter=[EditorParameter];

// References
EditorReference:
  (operator=OperatorInEditor)? '-' type=[ecore::EReference] '->' target=[EditorNode];

// Complex attribute conditions
EditorPatternAttributeCondition:
  {EditorPatternAttributeCondition}
  'attributeCondition' '{'
  constraints+=EditorPatternAttributeConstraint*
  '}';

EditorPatternAttributeConstraint:
  EditorPatternAttributeConstraintVariable | EditorPatternAttributeConstraintPredicate;

EditorPatternAttributeConstraintVariable:
  name=ID ':' type=[ecore::EDataType];

EditorPatternAttributeConstraintPredicate:
  name=[EditorAttributeConditionSpecification|ID]
  '(' args+=EditorPatternAttributeConstraintArgument? (',' args+=EditorPatternAttributeConstraintArgument)*
  ')';

EditorPatternAttributeConstraintArgument:
  EditorPatternAttributeConstraintAttributeValueExpression | EditorLiteralExpression |  EditorCountExpression | EditorEnumExpression | EditorPatternAttributeConstraintVariableReference | EditorParameterExpression;

EditorPatternAttributeConstraintAttributeValueExpression:
  editorNode=[EditorNode] '.' attribute=[ecore::EAttribute] (free?="*")?;
  
EditorPatternAttributeConstraintVariableReference:
  name=[EditorPatternAttributeConstraintVariable]
;

// Graph Conditions
EditorCondition:
  'condition' name=ID '='
  conditions+=EditorSimpleCondition ('&&' conditions+=EditorSimpleCondition)*;

EditorSimpleCondition:
  {EditorConditionReference}
  condition=[EditorCondition] |
  {EditorApplicationCondition}
  type=EditorApplicationConditionType pattern=[EditorPattern];

enum EditorApplicationConditionType:
  POSITIVE='enforce' |
  NEGATIVE='forbid';

EditorBindingExpression:
  ':=' node=[EditorNode];

// stochastic functions
EditorProbability:
	StochasticFunction | ArithmeticExpression;
	
StochasticFunction:
	functionExpression = StochasticFunctionExpression (parameter = ArithmeticExpression)?;

StochasticFunctionExpression:
	(operatorRange = StochasticRange)? distribution = StochasticDistribution 
	"(" mean = ArithmeticExpression ( hasSd ?= "," sd = ArithmeticExpression )?")";

enum PossibleStochasticRanges:
	NEUTRAL | POSITIVE | NEGATIVE;
	
enum StochasticRange returns PossibleStochasticRanges:
	POSITIVE = "+" | NEGATIVE = "-";

enum StochasticDistribution:
	NORMAL = "N" | UNIFORM = "U" | EXPONENTIAL = "Exp";	

//arithmetic functions
enum MultOperator:
	MULTIPLICATION = "*" | DIVISION = "/" | MODULO = "%";
	
enum MinMaxOperator:
	MIN = "min" | MAX = "max"
;
	
enum AddOperator:
	ADDITION = "+" | SUBTRACTION ="-";
	
enum AllOneParameterOperators:
	BRACKET | ROOT | ABSOLUTE | SIN | COS | TAN | E_EXPONENTIAL | LOGARITHMUS | NAT_LOG;
	
enum OneParameterOperator returns AllOneParameterOperators:
	ROOT = "sqrt" | ABSOLUTE = "abs" | SIN = "sin" | COS = "cos" | TAN = "tan" | 
	E_EXPONENTIAL ="exp" | LOGARITHMUS = "log" | NAT_LOG = "ln";

ArithmeticCalculationExpression:
	"calc" "("expression = ArithmeticExpression ")" ;
	
ArithmeticExpression:
	AddExpression;
	
AddExpression returns ArithmeticExpression:
	MultExpression ({AddExpression.left = current} addOperator = AddOperator right = MultExpression)*;

MultExpression returns ArithmeticExpression:
	ExpExpression ({MultExpression.left = current} 
		multOperator = MultOperator right = ExpExpression)*;

ExpExpression returns ArithmeticExpression:
	(MinMaxExpression | OneParameterArithmetics) ({ExpExpression.left = current} "^" right = (MinMaxExpression | OneParameterArithmetics))*;
	
MinMaxExpression returns ArithmeticExpression:
	{MinMaxExpression} minMaxOperator = MinMaxOperator '(' left = ArithmeticExpression "," right = ArithmeticExpression ')';

OneParameterArithmetics returns ArithmeticExpression:
	{OneParameterArithmetics} (negative?="-")? (operator = OneParameterOperator)? "("expression = ArithmeticExpression ")" 
	| ArithmeticAttribute;

ArithmeticAttribute returns ArithmeticExpression:
	{ArithmeticAttribute} (staticAttribute = ArithmeticNumber) | ArithmeticNodeAttribute | EditorCountExpression;
	
ArithmeticNodeAttribute:
	 (negative?="-")? node=[EditorNode] '.' attribute=[ecore::EAttribute];

ArithmeticNumber returns ecore::EDouble:
	 ('-')? INT ('.' INT)?;

/*
 * Attribute constraints library
 * This library allows the developer to provide her own constraint types (only for EDataTypes)
 * An EditorAttributeConditionSpecification represents a predicate with a number of typed parameters
 * An EditorAttributeConditionOperationalization is an operationalization of such a predicate (i.e., one way to fulfill the constraint)
 */
EditorAttributeConditionLibrary:
  {EditorAttributeConditionLibrary}
  'attributeConditionLibrary' '{'
  (conditionSpecifications+=EditorAttributeConditionSpecification)*
  '}';

EditorAttributeConditionSpecification:
  {EditorAttributeConditionSpecification}
  name=ID
  ('('
  (parameters+=EditorAttributeConditionParameter (',' parameters+=EditorAttributeConditionParameter)*)?
  ')')
  (('reuse' reusedConditionSpecification=[EditorAttributeConditionSpecification|ID]) | ('{'
  (operationalizations+=EditorAttributeConditionOperationalization*)
  '}'))?;

EditorAttributeConditionParameter:
  name=ID ':' type=[ecore::EDataType];

EditorAttributeConditionOperationalization:
  {EditorAttributeConditionOperationalization}
  operationalizationType = EditorAttributeConditionType '[' adornments+=EditorAttributeConditionAdornment+ ']'
  '{'
  target=EditorAttributeConditionTargetPlatform ':' specification=STRING
  '}';

/*
 * A BOUND parameter possesses a value prior to the evaluation of an operation, a free parameter is bound by the operation
 */
enum EditorAttributeConditionAdornment:
  BOUND='B' |
  FREE='F';
  
enum EditorAttributeConditionType:
  CHECK='check' |
  EXTEND='extend';

enum EditorAttributeConditionTargetPlatform:
  JAVA='Java';

  // This rule serves to have a common super class for pattern parameters and editor nodes
EditorParameterOrNode:
  (EditorNode | EditorParameter);