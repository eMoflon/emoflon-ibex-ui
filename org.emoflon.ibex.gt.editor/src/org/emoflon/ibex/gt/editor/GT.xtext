grammar org.emoflon.ibex.gt.editor.GT with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate gT "http://www.emoflon.org/ibex/gt/editor/GT"

EditorGTFile:
 	(imports+=EditorImport)*
 	(patterns+=EditorPattern |
	conditions+=EditorCondition 
//  | attributeConditionLibraries+=EditorAttributeConditionLibrary
	)*;
  
  // This rule serves to have a common super class for pattern parameters and editor nodes
EditorParameterOrNode:
  (EditorNode | EditorParameter);

EditorImport:
  'import' name=STRING;

EditorPattern:
  (abstract?='abstract')? type=EditorPatternType name=ID
  ('('
  (parameters+=EditorParameter (',' parameters+=EditorParameter)*)?
  ')')?
  ('refines' superPatterns+=[EditorPattern] (',' superPatterns+=[EditorPattern])*)?
  ('{'
  (nodes+=EditorNode | attributeConstraints+=EditorAttributeConstraint )*
  '}')?
  ('when' conditions+=[EditorCondition] ('||' conditions+=[EditorCondition])*)?
  (stochastic ?='@' probability = EditorProbability)?;

enum EditorPatternType:
  PATTERN='pattern' |
  RULE='rule';

EditorParameter:
  name=ID ':' type=[ecore::EDataType];

  // Nodes
EditorNode:
  (operator=EditorOperator)?
  name=ID ':' type=[ecore::EClass] (binding=EditorBindingExpression)?
  ('{'
  (attributes+=EditorAttributeAssignment | references+=EditorReference)
//attributeConditions+=EditorPatternAttributeCondition*
  '}')?;

enum EditorOperator:
  CONTEXT='98943JKHF9802nf&&3120ร4$ยง_3ยง' |
  CREATE='++' |
  DELETE='--';

  // Attribute Assignments and Conditions
EditorAttributeConstraint:
	lhs=EditorExpression relation=EditorRelation rhs=EditorExpression;
  
EditorAttributeAssignment:
	'.' attribute=[ecore::EAttribute] ':=' value=EditorExpression;

enum EditorRelation:
  GREATER='>' |
  GREATER_OR_EQUAL='>=' |
  EQUAL='==' |
  UNEQUAL='!=' |
  SMALLER_OR_EQUAL='<=' |
  SMALLER='<';

EditorExpression:
  EditorAttributeExpression | EditorLiteralExpression | EditorEnumExpression | EditorCountExpression |
  EditorParameterExpression | StochasticFunctionExpression | ArithmeticCalculationExpression;

EditorAttributeExpression:
  node=[EditorNode] '.' attribute=[ecore::EAttribute];
  
EditorCountExpression:
	'count' '(' invokedPatten = [EditorPattern] ')'
;

EditorLiteralExpression:
  value=('true' | 'false' | Number) |
  {StringConstant} value=STRING;

Number:
  ('-')? INT ('.' INT)?;

EditorEnumExpression:
  'enum::' literal=[ecore::EEnumLiteral];

EditorParameterExpression:
  'param::' parameter=[EditorParameter];

// References
EditorReference:
  (operator=EditorOperator)? '-' type=[ecore::EReference] '->' target=[EditorNode];

// Graph Conditions
EditorCondition:
  'condition' name=ID '='
  conditions+=EditorSimpleCondition ('&&' conditions+=EditorSimpleCondition)*;

EditorSimpleCondition:
  {EditorConditionReference}
  condition=[EditorCondition] |
  {EditorApplicationCondition}
  type=EditorApplicationConditionType pattern=[EditorPattern];

enum EditorApplicationConditionType:
  POSITIVE='enforce' |
  NEGATIVE='forbid';

EditorBindingExpression:
  ':=' node=[EditorNode];

// stochastic functions
EditorProbability:
	StochasticFunction | ArithmeticExpression;
	
StochasticFunction:
	functionExpression = StochasticFunctionExpression (parameter = ArithmeticExpression)?;

StochasticFunctionExpression:
	(operatorRange = StochasticRange)? distribution = StochasticDistribution 
	"(" mean = ArithmeticExpression ( hasSd ?= "," sd = ArithmeticExpression )?")";

enum PossibleStochasticRanges:
	NEUTRAL | POSITIVE | NEGATIVE;
	
enum StochasticRange returns PossibleStochasticRanges:
	POSITIVE = "+" | NEGATIVE = "-";

enum StochasticDistribution:
	NORMAL = "N" | UNIFORM = "U" | EXPONENTIAL = "Exp";	

//arithmetic functions
enum MultOperator:
	MULTIPLICATION = "*" | DIVISION = "/" | MODULO = "%";
	
enum MinMaxOperator:
	MIN = "min" | MAX = "max"
;
	
enum AddOperator:
	ADDITION = "+" | SUBTRACTION ="-";
	
enum AllOneParameterOperators:
	BRACKET | ROOT | ABSOLUTE | SIN | COS | TAN | E_EXPONENTIAL | LOGARITHMUS | NAT_LOG;
	
enum OneParameterOperator returns AllOneParameterOperators:
	ROOT = "sqrt" | ABSOLUTE = "abs" | SIN = "sin" | COS = "cos" | TAN = "tan" | 
	E_EXPONENTIAL ="exp" | LOGARITHMUS = "log" | NAT_LOG = "ln";

ArithmeticCalculationExpression:
	"calc" "("expression = ArithmeticExpression ")" ;
	
ArithmeticExpression:
	AddExpression;
	
AddExpression returns ArithmeticExpression:
	MultExpression ({AddExpression.left = current} addOperator = AddOperator right = MultExpression)*;

MultExpression returns ArithmeticExpression:
	ExpExpression ({MultExpression.left = current} 
		multOperator = MultOperator right = ExpExpression)*;

ExpExpression returns ArithmeticExpression:
	(MinMaxExpression | OneParameterArithmetics) ({ExpExpression.left = current} "^" right = (MinMaxExpression | OneParameterArithmetics))*;
	
MinMaxExpression returns ArithmeticExpression:
	{MinMaxExpression} minMaxOperator = MinMaxOperator '(' left = ArithmeticExpression "," right = ArithmeticExpression ')';

OneParameterArithmetics returns ArithmeticExpression:
	{OneParameterArithmetics} (negative?="-")? (operator = OneParameterOperator)? "("expression = ArithmeticExpression ")" 
	| ArithmeticAttribute;

ArithmeticAttribute returns ArithmeticExpression:
	{ArithmeticAttribute} (staticAttribute = ArithmeticNumber) | ArithmeticNodeAttribute | EditorCountExpression;
	
ArithmeticNodeAttribute:
	 (negative?="-")? node=[EditorNode] '.' attribute=[ecore::EAttribute];

ArithmeticNumber returns ecore::EDouble:
	 ('-')? INT ('.' INT)?;

//EditorPatternElement:
//  EditorNode | EditorPatternAttributeCondition;
//
//// Complex attribute conditions
//EditorPatternAttributeCondition:
//  {EditorPatternAttributeCondition}
//  'attributeCondition' '{'
//  constraints+=EditorPatternAttributeConstraint*
//  '}';
//
//EditorPatternAttributeConstraint:
//  EditorPatternAttributeConstraintVariable | EditorPatternAttributeConstraintPredicate;
//
//EditorPatternAttributeConstraintVariable:
//  name=ID ':' type=[ecore::EDataType];
//
//EditorPatternAttributeConstraintPredicate:
//  name=[EditorAttributeConditionSpecification|ID]
//  '(' args+=EditorPatternAttributeConstraintArgument? (',' args+=EditorPatternAttributeConstraintArgument)*
//  ')';

//EditorPatternAttributeConstraintArgument:
//  EditorPatternAttributeConstraintAttributeValueExpression | EditorLiteralExpression |  EditorCountExpression | EditorEnumExpression | EditorPatternAttributeConstraintVariableReference | EditorParameterExpression;
//
//EditorPatternAttributeConstraintAttributeValueExpression:
//  editorNode=[EditorNode] '.' attribute=[ecore::EAttribute] (free?="*")?;
//  
//EditorPatternAttributeConstraintVariableReference:
//  name=[EditorPatternAttributeConstraintVariable]
//;
//
///*
// * Attribute constraints library
// * This library allows the developer to provide her own constraint types (only for EDataTypes)
// * An EditorAttributeConditionSpecification represents a predicate with a number of typed parameters
// * An EditorAttributeConditionOperationalization is an operationalization of such a predicate (i.e., one way to fulfill the constraint)
// */
//EditorAttributeConditionLibrary:
//  {EditorAttributeConditionLibrary}
//  'attributeConditionLibrary' '{'
//  (conditionSpecifications+=EditorAttributeConditionSpecification)*
//  '}';
//
//EditorAttributeConditionSpecification:
//  {EditorAttributeConditionSpecification}
//  name=ID
//  ('('
//  (parameters+=EditorAttributeConditionParameter (',' parameters+=EditorAttributeConditionParameter)*)?
//  ')')
//  (('reuse' reusedConditionSpecification=[EditorAttributeConditionSpecification|ID]) | ('{'
//  (operationalizations+=EditorAttributeConditionOperationalization*)
//  '}'))?;
//
//EditorAttributeConditionParameter:
//  name=ID ':' type=[ecore::EDataType];
//
//EditorAttributeConditionOperationalization:
//  {EditorAttributeConditionOperationalization}
//  operationalizationType = EditorAttributeConditionType '[' adornments+=EditorAttributeConditionAdornment+ ']'
//  '{'
//  target=EditorAttributeConditionTargetPlatform ':' specification=STRING
//  '}';
//
///*
// * A BOUND parameter possesses a value prior to the evaluation of an operation, a free parameter is bound by the operation
// */
//enum EditorAttributeConditionAdornment:
//  BOUND='B' |
//  FREE='F';
//  
//enum EditorAttributeConditionType:
//  CHECK='check' |
//  EXTEND='extend';
//
//enum EditorAttributeConditionTargetPlatform:
//  JAVA='Java';
//