/*
 * generated by Xtext 2.27.0
 */
package org.emoflon.ibex.gt.editor.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.emoflon.ibex.gt.editor.gT.AddExpression;
import org.emoflon.ibex.gt.editor.gT.ArithmeticCalculationExpression;
import org.emoflon.ibex.gt.editor.gT.EditorApplicationCondition;
import org.emoflon.ibex.gt.editor.gT.EditorAttributeAssignment;
import org.emoflon.ibex.gt.editor.gT.EditorAttributeConstraint;
import org.emoflon.ibex.gt.editor.gT.EditorAttributeExpression;
import org.emoflon.ibex.gt.editor.gT.EditorCondition;
import org.emoflon.ibex.gt.editor.gT.EditorConditionReference;
import org.emoflon.ibex.gt.editor.gT.EditorCountExpression;
import org.emoflon.ibex.gt.editor.gT.EditorEnumExpression;
import org.emoflon.ibex.gt.editor.gT.EditorGTFile;
import org.emoflon.ibex.gt.editor.gT.EditorImport;
import org.emoflon.ibex.gt.editor.gT.EditorIteratorAttributeAssignmentItr;
import org.emoflon.ibex.gt.editor.gT.EditorIteratorAttributeAssignmentNode;
import org.emoflon.ibex.gt.editor.gT.EditorIteratorAttributeExpression;
import org.emoflon.ibex.gt.editor.gT.EditorIteratorReference;
import org.emoflon.ibex.gt.editor.gT.EditorLiteralExpression;
import org.emoflon.ibex.gt.editor.gT.EditorNode;
import org.emoflon.ibex.gt.editor.gT.EditorParameter;
import org.emoflon.ibex.gt.editor.gT.EditorParameterExpression;
import org.emoflon.ibex.gt.editor.gT.EditorPattern;
import org.emoflon.ibex.gt.editor.gT.EditorReference;
import org.emoflon.ibex.gt.editor.gT.EditorReferenceIterator;
import org.emoflon.ibex.gt.editor.gT.ExpExpression;
import org.emoflon.ibex.gt.editor.gT.GTPackage;
import org.emoflon.ibex.gt.editor.gT.MinMaxExpression;
import org.emoflon.ibex.gt.editor.gT.MultExpression;
import org.emoflon.ibex.gt.editor.gT.OneParameterArithmetics;
import org.emoflon.ibex.gt.editor.gT.StochasticFunction;
import org.emoflon.ibex.gt.editor.gT.StochasticFunctionExpression;
import org.emoflon.ibex.gt.editor.gT.StringConstant;
import org.emoflon.ibex.gt.editor.services.GTGrammarAccess;

@SuppressWarnings("all")
public class GTSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private GTGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == GTPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case GTPackage.ADD_EXPRESSION:
				sequence_AddExpression(context, (AddExpression) semanticObject); 
				return; 
			case GTPackage.ARITHMETIC_CALCULATION_EXPRESSION:
				sequence_ArithmeticCalculationExpression(context, (ArithmeticCalculationExpression) semanticObject); 
				return; 
			case GTPackage.EDITOR_APPLICATION_CONDITION:
				sequence_EditorSimpleCondition(context, (EditorApplicationCondition) semanticObject); 
				return; 
			case GTPackage.EDITOR_ATTRIBUTE_ASSIGNMENT:
				sequence_EditorAttributeAssignment(context, (EditorAttributeAssignment) semanticObject); 
				return; 
			case GTPackage.EDITOR_ATTRIBUTE_CONSTRAINT:
				sequence_EditorAttributeConstraint(context, (EditorAttributeConstraint) semanticObject); 
				return; 
			case GTPackage.EDITOR_ATTRIBUTE_EXPRESSION:
				sequence_EditorAttributeExpression(context, (EditorAttributeExpression) semanticObject); 
				return; 
			case GTPackage.EDITOR_CONDITION:
				sequence_EditorCondition(context, (EditorCondition) semanticObject); 
				return; 
			case GTPackage.EDITOR_CONDITION_REFERENCE:
				sequence_EditorSimpleCondition(context, (EditorConditionReference) semanticObject); 
				return; 
			case GTPackage.EDITOR_COUNT_EXPRESSION:
				sequence_EditorCountExpression(context, (EditorCountExpression) semanticObject); 
				return; 
			case GTPackage.EDITOR_ENUM_EXPRESSION:
				sequence_EditorEnumExpression(context, (EditorEnumExpression) semanticObject); 
				return; 
			case GTPackage.EDITOR_GT_FILE:
				sequence_EditorGTFile(context, (EditorGTFile) semanticObject); 
				return; 
			case GTPackage.EDITOR_IMPORT:
				sequence_EditorImport(context, (EditorImport) semanticObject); 
				return; 
			case GTPackage.EDITOR_ITERATOR_ATTRIBUTE_ASSIGNMENT_ITR:
				sequence_EditorIteratorAttributeAssignmentItr(context, (EditorIteratorAttributeAssignmentItr) semanticObject); 
				return; 
			case GTPackage.EDITOR_ITERATOR_ATTRIBUTE_ASSIGNMENT_NODE:
				sequence_EditorIteratorAttributeAssignmentNode(context, (EditorIteratorAttributeAssignmentNode) semanticObject); 
				return; 
			case GTPackage.EDITOR_ITERATOR_ATTRIBUTE_EXPRESSION:
				sequence_EditorIteratorAttributeExpression(context, (EditorIteratorAttributeExpression) semanticObject); 
				return; 
			case GTPackage.EDITOR_ITERATOR_REFERENCE:
				sequence_EditorIteratorReference(context, (EditorIteratorReference) semanticObject); 
				return; 
			case GTPackage.EDITOR_LITERAL_EXPRESSION:
				sequence_EditorLiteralExpression(context, (EditorLiteralExpression) semanticObject); 
				return; 
			case GTPackage.EDITOR_NODE:
				sequence_EditorNode(context, (EditorNode) semanticObject); 
				return; 
			case GTPackage.EDITOR_PARAMETER:
				sequence_EditorParameter(context, (EditorParameter) semanticObject); 
				return; 
			case GTPackage.EDITOR_PARAMETER_EXPRESSION:
				sequence_EditorParameterExpression(context, (EditorParameterExpression) semanticObject); 
				return; 
			case GTPackage.EDITOR_PATTERN:
				sequence_EditorPattern(context, (EditorPattern) semanticObject); 
				return; 
			case GTPackage.EDITOR_REFERENCE:
				sequence_EditorReference(context, (EditorReference) semanticObject); 
				return; 
			case GTPackage.EDITOR_REFERENCE_ITERATOR:
				sequence_EditorReferenceIterator(context, (EditorReferenceIterator) semanticObject); 
				return; 
			case GTPackage.EXP_EXPRESSION:
				sequence_ExpExpression(context, (ExpExpression) semanticObject); 
				return; 
			case GTPackage.MIN_MAX_EXPRESSION:
				sequence_MinMaxExpression(context, (MinMaxExpression) semanticObject); 
				return; 
			case GTPackage.MULT_EXPRESSION:
				sequence_MultExpression(context, (MultExpression) semanticObject); 
				return; 
			case GTPackage.ONE_PARAMETER_ARITHMETICS:
				sequence_OneParameterArithmetics(context, (OneParameterArithmetics) semanticObject); 
				return; 
			case GTPackage.STOCHASTIC_FUNCTION:
				sequence_StochasticFunction(context, (StochasticFunction) semanticObject); 
				return; 
			case GTPackage.STOCHASTIC_FUNCTION_EXPRESSION:
				sequence_StochasticFunctionExpression(context, (StochasticFunctionExpression) semanticObject); 
				return; 
			case GTPackage.STRING_CONSTANT:
				sequence_EditorLiteralExpression(context, (StringConstant) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     EditorProbability returns AddExpression
	 *     ArithmeticExpression returns AddExpression
	 *     AddExpression returns AddExpression
	 *     AddExpression.AddExpression_1_0 returns AddExpression
	 *
	 * Constraint:
	 *     (left=AddExpression_AddExpression_1_0 addOperator=AddOperator right=MultExpression)
	 * </pre>
	 */
	protected void sequence_AddExpression(ISerializationContext context, AddExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.ADD_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.ADD_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.ADD_EXPRESSION__ADD_OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.ADD_EXPRESSION__ADD_OPERATOR));
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.ADD_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.ADD_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAddExpressionAccess().getAddExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAddExpressionAccess().getAddOperatorAddOperatorEnumRuleCall_1_1_0(), semanticObject.getAddOperator());
		feeder.accept(grammarAccess.getAddExpressionAccess().getRightMultExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EditorExpression returns ArithmeticCalculationExpression
	 *     ArithmeticCalculationExpression returns ArithmeticCalculationExpression
	 *
	 * Constraint:
	 *     expression=ArithmeticExpression
	 * </pre>
	 */
	protected void sequence_ArithmeticCalculationExpression(ISerializationContext context, ArithmeticCalculationExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.ARITHMETIC_CALCULATION_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.ARITHMETIC_CALCULATION_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArithmeticCalculationExpressionAccess().getExpressionArithmeticExpressionParserRuleCall_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EditorAttributeAssignment returns EditorAttributeAssignment
	 *
	 * Constraint:
	 *     (attribute=[EAttribute|ID] value=EditorExpression)
	 * </pre>
	 */
	protected void sequence_EditorAttributeAssignment(ISerializationContext context, EditorAttributeAssignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.EDITOR_ATTRIBUTE_ASSIGNMENT__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.EDITOR_ATTRIBUTE_ASSIGNMENT__ATTRIBUTE));
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.EDITOR_ATTRIBUTE_ASSIGNMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.EDITOR_ATTRIBUTE_ASSIGNMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEditorAttributeAssignmentAccess().getAttributeEAttributeIDTerminalRuleCall_1_0_1(), semanticObject.eGet(GTPackage.Literals.EDITOR_ATTRIBUTE_ASSIGNMENT__ATTRIBUTE, false));
		feeder.accept(grammarAccess.getEditorAttributeAssignmentAccess().getValueEditorExpressionParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EditorAttributeConstraint returns EditorAttributeConstraint
	 *
	 * Constraint:
	 *     (lhs=EditorExpression relation=EditorRelation rhs=EditorExpression)
	 * </pre>
	 */
	protected void sequence_EditorAttributeConstraint(ISerializationContext context, EditorAttributeConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.EDITOR_ATTRIBUTE_CONSTRAINT__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.EDITOR_ATTRIBUTE_CONSTRAINT__LHS));
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.EDITOR_ATTRIBUTE_CONSTRAINT__RELATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.EDITOR_ATTRIBUTE_CONSTRAINT__RELATION));
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.EDITOR_ATTRIBUTE_CONSTRAINT__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.EDITOR_ATTRIBUTE_CONSTRAINT__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEditorAttributeConstraintAccess().getLhsEditorExpressionParserRuleCall_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getEditorAttributeConstraintAccess().getRelationEditorRelationEnumRuleCall_2_0(), semanticObject.getRelation());
		feeder.accept(grammarAccess.getEditorAttributeConstraintAccess().getRhsEditorExpressionParserRuleCall_3_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EditorAttributeExpression returns EditorAttributeExpression
	 *     EditorProbability returns EditorAttributeExpression
	 *     ArithmeticExpression returns EditorAttributeExpression
	 *     AddExpression returns EditorAttributeExpression
	 *     AddExpression.AddExpression_1_0 returns EditorAttributeExpression
	 *     MultExpression returns EditorAttributeExpression
	 *     MultExpression.MultExpression_1_0 returns EditorAttributeExpression
	 *     ExpExpression returns EditorAttributeExpression
	 *     ExpExpression.ExpExpression_1_0 returns EditorAttributeExpression
	 *     OneParameterArithmetics returns EditorAttributeExpression
	 *     ArithmeticAttribute returns EditorAttributeExpression
	 *
	 * Constraint:
	 *     (node=[EditorNode|ID] attribute=[EAttribute|ID])
	 * </pre>
	 */
	protected void sequence_EditorAttributeExpression(ISerializationContext context, EditorAttributeExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.EDITOR_ATTRIBUTE_EXPRESSION__NODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.EDITOR_ATTRIBUTE_EXPRESSION__NODE));
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.EDITOR_ATTRIBUTE_EXPRESSION__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.EDITOR_ATTRIBUTE_EXPRESSION__ATTRIBUTE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEditorAttributeExpressionAccess().getNodeEditorNodeIDTerminalRuleCall_0_0_1(), semanticObject.eGet(GTPackage.Literals.EDITOR_ATTRIBUTE_EXPRESSION__NODE, false));
		feeder.accept(grammarAccess.getEditorAttributeExpressionAccess().getAttributeEAttributeIDTerminalRuleCall_2_0_1(), semanticObject.eGet(GTPackage.Literals.EDITOR_ATTRIBUTE_EXPRESSION__ATTRIBUTE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EditorCondition returns EditorCondition
	 *
	 * Constraint:
	 *     (name=ID conditions+=EditorSimpleCondition conditions+=EditorSimpleCondition*)
	 * </pre>
	 */
	protected void sequence_EditorCondition(ISerializationContext context, EditorCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EditorCountExpression returns EditorCountExpression
	 *     EditorProbability returns EditorCountExpression
	 *     ArithmeticExpression returns EditorCountExpression
	 *     AddExpression returns EditorCountExpression
	 *     AddExpression.AddExpression_1_0 returns EditorCountExpression
	 *     MultExpression returns EditorCountExpression
	 *     MultExpression.MultExpression_1_0 returns EditorCountExpression
	 *     ExpExpression returns EditorCountExpression
	 *     ExpExpression.ExpExpression_1_0 returns EditorCountExpression
	 *     OneParameterArithmetics returns EditorCountExpression
	 *     ArithmeticAttribute returns EditorCountExpression
	 *
	 * Constraint:
	 *     invokedPatten=[EditorPattern|ID]
	 * </pre>
	 */
	protected void sequence_EditorCountExpression(ISerializationContext context, EditorCountExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.EDITOR_COUNT_EXPRESSION__INVOKED_PATTEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.EDITOR_COUNT_EXPRESSION__INVOKED_PATTEN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEditorCountExpressionAccess().getInvokedPattenEditorPatternIDTerminalRuleCall_2_0_1(), semanticObject.eGet(GTPackage.Literals.EDITOR_COUNT_EXPRESSION__INVOKED_PATTEN, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EditorExpression returns EditorEnumExpression
	 *     EditorEnumExpression returns EditorEnumExpression
	 *
	 * Constraint:
	 *     literal=[EEnumLiteral|ID]
	 * </pre>
	 */
	protected void sequence_EditorEnumExpression(ISerializationContext context, EditorEnumExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.EDITOR_ENUM_EXPRESSION__LITERAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.EDITOR_ENUM_EXPRESSION__LITERAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEditorEnumExpressionAccess().getLiteralEEnumLiteralIDTerminalRuleCall_1_0_1(), semanticObject.eGet(GTPackage.Literals.EDITOR_ENUM_EXPRESSION__LITERAL, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EditorGTFile returns EditorGTFile
	 *
	 * Constraint:
	 *     (imports+=EditorImport+ | (imports+=EditorImport+ (patterns+=EditorPattern | conditions+=EditorCondition)+))?
	 * </pre>
	 */
	protected void sequence_EditorGTFile(ISerializationContext context, EditorGTFile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EditorImport returns EditorImport
	 *
	 * Constraint:
	 *     name=STRING
	 * </pre>
	 */
	protected void sequence_EditorImport(ISerializationContext context, EditorImport semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.EDITOR_IMPORT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.EDITOR_IMPORT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEditorImportAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EditorIteratorAttributeAssignment returns EditorIteratorAttributeAssignmentItr
	 *     EditorIteratorAttributeAssignmentItr returns EditorIteratorAttributeAssignmentItr
	 *
	 * Constraint:
	 *     (iteratorAttribute=EditorIteratorAttributeExpression value=EditorExpression)
	 * </pre>
	 */
	protected void sequence_EditorIteratorAttributeAssignmentItr(ISerializationContext context, EditorIteratorAttributeAssignmentItr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.EDITOR_ITERATOR_ATTRIBUTE_ASSIGNMENT_ITR__ITERATOR_ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.EDITOR_ITERATOR_ATTRIBUTE_ASSIGNMENT_ITR__ITERATOR_ATTRIBUTE));
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.EDITOR_ITERATOR_ATTRIBUTE_ASSIGNMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.EDITOR_ITERATOR_ATTRIBUTE_ASSIGNMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEditorIteratorAttributeAssignmentItrAccess().getIteratorAttributeEditorIteratorAttributeExpressionParserRuleCall_0_0(), semanticObject.getIteratorAttribute());
		feeder.accept(grammarAccess.getEditorIteratorAttributeAssignmentItrAccess().getValueEditorExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EditorIteratorAttributeAssignment returns EditorIteratorAttributeAssignmentNode
	 *     EditorIteratorAttributeAssignmentNode returns EditorIteratorAttributeAssignmentNode
	 *
	 * Constraint:
	 *     (nodeAttribute=EditorAttributeExpression value=EditorExpression)
	 * </pre>
	 */
	protected void sequence_EditorIteratorAttributeAssignmentNode(ISerializationContext context, EditorIteratorAttributeAssignmentNode semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.EDITOR_ITERATOR_ATTRIBUTE_ASSIGNMENT_NODE__NODE_ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.EDITOR_ITERATOR_ATTRIBUTE_ASSIGNMENT_NODE__NODE_ATTRIBUTE));
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.EDITOR_ITERATOR_ATTRIBUTE_ASSIGNMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.EDITOR_ITERATOR_ATTRIBUTE_ASSIGNMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEditorIteratorAttributeAssignmentNodeAccess().getNodeAttributeEditorAttributeExpressionParserRuleCall_0_0(), semanticObject.getNodeAttribute());
		feeder.accept(grammarAccess.getEditorIteratorAttributeAssignmentNodeAccess().getValueEditorExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EditorIteratorAttributeExpression returns EditorIteratorAttributeExpression
	 *     EditorProbability returns EditorIteratorAttributeExpression
	 *     ArithmeticExpression returns EditorIteratorAttributeExpression
	 *     AddExpression returns EditorIteratorAttributeExpression
	 *     AddExpression.AddExpression_1_0 returns EditorIteratorAttributeExpression
	 *     MultExpression returns EditorIteratorAttributeExpression
	 *     MultExpression.MultExpression_1_0 returns EditorIteratorAttributeExpression
	 *     ExpExpression returns EditorIteratorAttributeExpression
	 *     ExpExpression.ExpExpression_1_0 returns EditorIteratorAttributeExpression
	 *     OneParameterArithmetics returns EditorIteratorAttributeExpression
	 *     ArithmeticAttribute returns EditorIteratorAttributeExpression
	 *
	 * Constraint:
	 *     (iterator=[EditorReferenceIterator|ID] attribute=[EAttribute|ID])
	 * </pre>
	 */
	protected void sequence_EditorIteratorAttributeExpression(ISerializationContext context, EditorIteratorAttributeExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.EDITOR_ITERATOR_ATTRIBUTE_EXPRESSION__ITERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.EDITOR_ITERATOR_ATTRIBUTE_EXPRESSION__ITERATOR));
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.EDITOR_ITERATOR_ATTRIBUTE_EXPRESSION__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.EDITOR_ITERATOR_ATTRIBUTE_EXPRESSION__ATTRIBUTE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEditorIteratorAttributeExpressionAccess().getIteratorEditorReferenceIteratorIDTerminalRuleCall_1_0_1(), semanticObject.eGet(GTPackage.Literals.EDITOR_ITERATOR_ATTRIBUTE_EXPRESSION__ITERATOR, false));
		feeder.accept(grammarAccess.getEditorIteratorAttributeExpressionAccess().getAttributeEAttributeIDTerminalRuleCall_3_0_1(), semanticObject.eGet(GTPackage.Literals.EDITOR_ITERATOR_ATTRIBUTE_EXPRESSION__ATTRIBUTE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EditorIteratorReference returns EditorIteratorReference
	 *
	 * Constraint:
	 *     (operator=EditorOperator source=[EditorNode|ID] type=[EReference|ID] target=[EditorReferenceIterator|ID])
	 * </pre>
	 */
	protected void sequence_EditorIteratorReference(ISerializationContext context, EditorIteratorReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.EDITOR_ITERATOR_REFERENCE__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.EDITOR_ITERATOR_REFERENCE__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.EDITOR_ITERATOR_REFERENCE__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.EDITOR_ITERATOR_REFERENCE__SOURCE));
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.EDITOR_ITERATOR_REFERENCE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.EDITOR_ITERATOR_REFERENCE__TYPE));
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.EDITOR_ITERATOR_REFERENCE__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.EDITOR_ITERATOR_REFERENCE__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEditorIteratorReferenceAccess().getOperatorEditorOperatorEnumRuleCall_0_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getEditorIteratorReferenceAccess().getSourceEditorNodeIDTerminalRuleCall_1_0_1(), semanticObject.eGet(GTPackage.Literals.EDITOR_ITERATOR_REFERENCE__SOURCE, false));
		feeder.accept(grammarAccess.getEditorIteratorReferenceAccess().getTypeEReferenceIDTerminalRuleCall_3_0_1(), semanticObject.eGet(GTPackage.Literals.EDITOR_ITERATOR_REFERENCE__TYPE, false));
		feeder.accept(grammarAccess.getEditorIteratorReferenceAccess().getTargetEditorReferenceIteratorIDTerminalRuleCall_5_0_1(), semanticObject.eGet(GTPackage.Literals.EDITOR_ITERATOR_REFERENCE__TARGET, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EditorLiteralExpression returns EditorLiteralExpression
	 *     EditorProbability returns EditorLiteralExpression
	 *     ArithmeticExpression returns EditorLiteralExpression
	 *     AddExpression returns EditorLiteralExpression
	 *     AddExpression.AddExpression_1_0 returns EditorLiteralExpression
	 *     MultExpression returns EditorLiteralExpression
	 *     MultExpression.MultExpression_1_0 returns EditorLiteralExpression
	 *     ExpExpression returns EditorLiteralExpression
	 *     ExpExpression.ExpExpression_1_0 returns EditorLiteralExpression
	 *     OneParameterArithmetics returns EditorLiteralExpression
	 *     ArithmeticAttribute returns EditorLiteralExpression
	 *
	 * Constraint:
	 *     (value='true' | value='false' | value=Number)
	 * </pre>
	 */
	protected void sequence_EditorLiteralExpression(ISerializationContext context, EditorLiteralExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EditorLiteralExpression returns StringConstant
	 *     EditorProbability returns StringConstant
	 *     ArithmeticExpression returns StringConstant
	 *     AddExpression returns StringConstant
	 *     AddExpression.AddExpression_1_0 returns StringConstant
	 *     MultExpression returns StringConstant
	 *     MultExpression.MultExpression_1_0 returns StringConstant
	 *     ExpExpression returns StringConstant
	 *     ExpExpression.ExpExpression_1_0 returns StringConstant
	 *     OneParameterArithmetics returns StringConstant
	 *     ArithmeticAttribute returns StringConstant
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_EditorLiteralExpression(ISerializationContext context, StringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.EDITOR_LITERAL_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.EDITOR_LITERAL_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEditorLiteralExpressionAccess().getValueSTRINGTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EditorParameterOrNode returns EditorNode
	 *     EditorNode returns EditorNode
	 *
	 * Constraint:
	 *     (
	 *         operator=EditorOperator? 
	 *         local?='local'? 
	 *         name=ID 
	 *         type=[EClass|ID] 
	 *         (attributes+=EditorAttributeAssignment | references+=EditorReference | iterators+=EditorReferenceIterator)*
	 *     )
	 * </pre>
	 */
	protected void sequence_EditorNode(ISerializationContext context, EditorNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EditorExpression returns EditorParameterExpression
	 *     EditorParameterExpression returns EditorParameterExpression
	 *
	 * Constraint:
	 *     parameter=[EditorParameter|ID]
	 * </pre>
	 */
	protected void sequence_EditorParameterExpression(ISerializationContext context, EditorParameterExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.EDITOR_PARAMETER_EXPRESSION__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.EDITOR_PARAMETER_EXPRESSION__PARAMETER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEditorParameterExpressionAccess().getParameterEditorParameterIDTerminalRuleCall_1_0_1(), semanticObject.eGet(GTPackage.Literals.EDITOR_PARAMETER_EXPRESSION__PARAMETER, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EditorParameterOrNode returns EditorParameter
	 *     EditorParameter returns EditorParameter
	 *
	 * Constraint:
	 *     (name=ID type=[EDataType|ID])
	 * </pre>
	 */
	protected void sequence_EditorParameter(ISerializationContext context, EditorParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.EDITOR_PARAMETER_OR_NODE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.EDITOR_PARAMETER_OR_NODE__NAME));
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.EDITOR_PARAMETER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.EDITOR_PARAMETER__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEditorParameterAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getEditorParameterAccess().getTypeEDataTypeIDTerminalRuleCall_2_0_1(), semanticObject.eGet(GTPackage.Literals.EDITOR_PARAMETER__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EditorPattern returns EditorPattern
	 *
	 * Constraint:
	 *     (
	 *         abstract?='abstract'? 
	 *         type=EditorPatternType 
	 *         name=ID 
	 *         (parameters+=EditorParameter parameters+=EditorParameter*)? 
	 *         (superPatterns+=[EditorPattern|ID] superPatterns+=[EditorPattern|ID]*)? 
	 *         (nodes+=EditorNode | attributeConstraints+=EditorAttributeConstraint)* 
	 *         (conditions+=[EditorCondition|ID] conditions+=[EditorCondition|ID]*)? 
	 *         (stochastic?='@' probability=EditorProbability)?
	 *     )
	 * </pre>
	 */
	protected void sequence_EditorPattern(ISerializationContext context, EditorPattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EditorReferenceIterator returns EditorReferenceIterator
	 *
	 * Constraint:
	 *     (
	 *         type=[EReference|ID] 
	 *         name=ID 
	 *         subType=[EClass|ID]? 
	 *         (iteratorAttributes+=EditorIteratorAttributeAssignment | references+=EditorIteratorReference)+
	 *     )
	 * </pre>
	 */
	protected void sequence_EditorReferenceIterator(ISerializationContext context, EditorReferenceIterator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EditorReference returns EditorReference
	 *
	 * Constraint:
	 *     (operator=EditorOperator? type=[EReference|ID] target=[EditorNode|ID])
	 * </pre>
	 */
	protected void sequence_EditorReference(ISerializationContext context, EditorReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EditorSimpleCondition returns EditorApplicationCondition
	 *
	 * Constraint:
	 *     (type=EditorApplicationConditionType pattern=[EditorPattern|ID])
	 * </pre>
	 */
	protected void sequence_EditorSimpleCondition(ISerializationContext context, EditorApplicationCondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.EDITOR_APPLICATION_CONDITION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.EDITOR_APPLICATION_CONDITION__TYPE));
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.EDITOR_APPLICATION_CONDITION__PATTERN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.EDITOR_APPLICATION_CONDITION__PATTERN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEditorSimpleConditionAccess().getTypeEditorApplicationConditionTypeEnumRuleCall_1_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getEditorSimpleConditionAccess().getPatternEditorPatternIDTerminalRuleCall_1_2_0_1(), semanticObject.eGet(GTPackage.Literals.EDITOR_APPLICATION_CONDITION__PATTERN, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EditorSimpleCondition returns EditorConditionReference
	 *
	 * Constraint:
	 *     condition=[EditorCondition|ID]
	 * </pre>
	 */
	protected void sequence_EditorSimpleCondition(ISerializationContext context, EditorConditionReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.EDITOR_CONDITION_REFERENCE__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.EDITOR_CONDITION_REFERENCE__CONDITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEditorSimpleConditionAccess().getConditionEditorConditionIDTerminalRuleCall_0_1_0_1(), semanticObject.eGet(GTPackage.Literals.EDITOR_CONDITION_REFERENCE__CONDITION, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EditorProbability returns ExpExpression
	 *     ArithmeticExpression returns ExpExpression
	 *     AddExpression returns ExpExpression
	 *     AddExpression.AddExpression_1_0 returns ExpExpression
	 *     MultExpression returns ExpExpression
	 *     MultExpression.MultExpression_1_0 returns ExpExpression
	 *     ExpExpression returns ExpExpression
	 *     ExpExpression.ExpExpression_1_0 returns ExpExpression
	 *
	 * Constraint:
	 *     (left=ExpExpression_ExpExpression_1_0 (right=MinMaxExpression | right=OneParameterArithmetics))
	 * </pre>
	 */
	protected void sequence_ExpExpression(ISerializationContext context, ExpExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EditorProbability returns MinMaxExpression
	 *     ArithmeticExpression returns MinMaxExpression
	 *     AddExpression returns MinMaxExpression
	 *     AddExpression.AddExpression_1_0 returns MinMaxExpression
	 *     MultExpression returns MinMaxExpression
	 *     MultExpression.MultExpression_1_0 returns MinMaxExpression
	 *     ExpExpression returns MinMaxExpression
	 *     ExpExpression.ExpExpression_1_0 returns MinMaxExpression
	 *     MinMaxExpression returns MinMaxExpression
	 *
	 * Constraint:
	 *     (minMaxOperator=MinMaxOperator left=ArithmeticExpression right=ArithmeticExpression)
	 * </pre>
	 */
	protected void sequence_MinMaxExpression(ISerializationContext context, MinMaxExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.MIN_MAX_EXPRESSION__MIN_MAX_OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.MIN_MAX_EXPRESSION__MIN_MAX_OPERATOR));
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.MIN_MAX_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.MIN_MAX_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.MIN_MAX_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.MIN_MAX_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMinMaxExpressionAccess().getMinMaxOperatorMinMaxOperatorEnumRuleCall_1_0(), semanticObject.getMinMaxOperator());
		feeder.accept(grammarAccess.getMinMaxExpressionAccess().getLeftArithmeticExpressionParserRuleCall_3_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMinMaxExpressionAccess().getRightArithmeticExpressionParserRuleCall_5_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EditorProbability returns MultExpression
	 *     ArithmeticExpression returns MultExpression
	 *     AddExpression returns MultExpression
	 *     AddExpression.AddExpression_1_0 returns MultExpression
	 *     MultExpression returns MultExpression
	 *     MultExpression.MultExpression_1_0 returns MultExpression
	 *
	 * Constraint:
	 *     (left=MultExpression_MultExpression_1_0 multOperator=MultOperator right=ExpExpression)
	 * </pre>
	 */
	protected void sequence_MultExpression(ISerializationContext context, MultExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.MULT_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.MULT_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.MULT_EXPRESSION__MULT_OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.MULT_EXPRESSION__MULT_OPERATOR));
			if (transientValues.isValueTransient(semanticObject, GTPackage.Literals.MULT_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GTPackage.Literals.MULT_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultExpressionAccess().getMultExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultExpressionAccess().getMultOperatorMultOperatorEnumRuleCall_1_1_0(), semanticObject.getMultOperator());
		feeder.accept(grammarAccess.getMultExpressionAccess().getRightExpExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EditorProbability returns OneParameterArithmetics
	 *     ArithmeticExpression returns OneParameterArithmetics
	 *     AddExpression returns OneParameterArithmetics
	 *     AddExpression.AddExpression_1_0 returns OneParameterArithmetics
	 *     MultExpression returns OneParameterArithmetics
	 *     MultExpression.MultExpression_1_0 returns OneParameterArithmetics
	 *     ExpExpression returns OneParameterArithmetics
	 *     ExpExpression.ExpExpression_1_0 returns OneParameterArithmetics
	 *     OneParameterArithmetics returns OneParameterArithmetics
	 *
	 * Constraint:
	 *     (negative?='-'? operator=OneParameterOperator? expression=ArithmeticExpression)
	 * </pre>
	 */
	protected void sequence_OneParameterArithmetics(ISerializationContext context, OneParameterArithmetics semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EditorExpression returns StochasticFunctionExpression
	 *     StochasticFunctionExpression returns StochasticFunctionExpression
	 *
	 * Constraint:
	 *     (operatorRange=StochasticRange? distribution=StochasticDistribution mean=ArithmeticExpression (hasSd?=',' sd=ArithmeticExpression)?)
	 * </pre>
	 */
	protected void sequence_StochasticFunctionExpression(ISerializationContext context, StochasticFunctionExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EditorProbability returns StochasticFunction
	 *     StochasticFunction returns StochasticFunction
	 *
	 * Constraint:
	 *     (functionExpression=StochasticFunctionExpression parameter=ArithmeticExpression?)
	 * </pre>
	 */
	protected void sequence_StochasticFunction(ISerializationContext context, StochasticFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
