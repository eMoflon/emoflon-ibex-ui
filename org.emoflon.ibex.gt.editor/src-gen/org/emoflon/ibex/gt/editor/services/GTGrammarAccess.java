/*
 * generated by Xtext 2.27.0
 */
package org.emoflon.ibex.gt.editor.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class GTGrammarAccess extends AbstractElementFinder.AbstractGrammarElementFinder {
	
	public class EditorGTFileElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.EditorGTFile");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cImportsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cImportsEditorImportParserRuleCall_0_0 = (RuleCall)cImportsAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cPatternsAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cPatternsEditorPatternParserRuleCall_1_0_0 = (RuleCall)cPatternsAssignment_1_0.eContents().get(0);
		private final Assignment cConditionsAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cConditionsEditorConditionParserRuleCall_1_1_0 = (RuleCall)cConditionsAssignment_1_1.eContents().get(0);
		
		//EditorGTFile:
		//     (imports+=EditorImport)*
		//     (patterns+=EditorPattern | conditions+=EditorCondition)*;
		@Override public ParserRule getRule() { return rule; }
		
		//(imports+=EditorImport)*
		//(patterns+=EditorPattern | conditions+=EditorCondition)*
		public Group getGroup() { return cGroup; }
		
		//(imports+=EditorImport)*
		public Assignment getImportsAssignment_0() { return cImportsAssignment_0; }
		
		//EditorImport
		public RuleCall getImportsEditorImportParserRuleCall_0_0() { return cImportsEditorImportParserRuleCall_0_0; }
		
		//(patterns+=EditorPattern | conditions+=EditorCondition)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//patterns+=EditorPattern
		public Assignment getPatternsAssignment_1_0() { return cPatternsAssignment_1_0; }
		
		//EditorPattern
		public RuleCall getPatternsEditorPatternParserRuleCall_1_0_0() { return cPatternsEditorPatternParserRuleCall_1_0_0; }
		
		//conditions+=EditorCondition
		public Assignment getConditionsAssignment_1_1() { return cConditionsAssignment_1_1; }
		
		//EditorCondition
		public RuleCall getConditionsEditorConditionParserRuleCall_1_1_0() { return cConditionsEditorConditionParserRuleCall_1_1_0; }
	}
	public class EditorParameterOrNodeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.EditorParameterOrNode");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cEditorNodeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEditorParameterParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//  // This rule serves to have a common super class for pattern parameters and editor nodes
		//EditorParameterOrNode:
		//  (EditorNode | EditorParameter);
		@Override public ParserRule getRule() { return rule; }
		
		//(EditorNode | EditorParameter)
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//EditorNode
		public RuleCall getEditorNodeParserRuleCall_0() { return cEditorNodeParserRuleCall_0; }
		
		//EditorParameter
		public RuleCall getEditorParameterParserRuleCall_1() { return cEditorParameterParserRuleCall_1; }
	}
	public class EditorImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.EditorImport");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameSTRINGTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//EditorImport:
		//  'import' name=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//'import' name=STRING
		public Group getGroup() { return cGroup; }
		
		//'import'
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }
		
		//name=STRING
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_1_0() { return cNameSTRINGTerminalRuleCall_1_0; }
	}
	public class EditorPatternElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.EditorPattern");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cAbstractAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cAbstractAbstractKeyword_0_0 = (Keyword)cAbstractAssignment_0.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeEditorPatternTypeEnumRuleCall_1_0 = (RuleCall)cTypeAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cLeftParenthesisKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Assignment cParametersAssignment_3_1_0 = (Assignment)cGroup_3_1.eContents().get(0);
		private final RuleCall cParametersEditorParameterParserRuleCall_3_1_0_0 = (RuleCall)cParametersAssignment_3_1_0.eContents().get(0);
		private final Group cGroup_3_1_1 = (Group)cGroup_3_1.eContents().get(1);
		private final Keyword cCommaKeyword_3_1_1_0 = (Keyword)cGroup_3_1_1.eContents().get(0);
		private final Assignment cParametersAssignment_3_1_1_1 = (Assignment)cGroup_3_1_1.eContents().get(1);
		private final RuleCall cParametersEditorParameterParserRuleCall_3_1_1_1_0 = (RuleCall)cParametersAssignment_3_1_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3_2 = (Keyword)cGroup_3.eContents().get(2);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cRefinesKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cSuperPatternsAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final CrossReference cSuperPatternsEditorPatternCrossReference_4_1_0 = (CrossReference)cSuperPatternsAssignment_4_1.eContents().get(0);
		private final RuleCall cSuperPatternsEditorPatternIDTerminalRuleCall_4_1_0_1 = (RuleCall)cSuperPatternsEditorPatternCrossReference_4_1_0.eContents().get(1);
		private final Group cGroup_4_2 = (Group)cGroup_4.eContents().get(2);
		private final Keyword cCommaKeyword_4_2_0 = (Keyword)cGroup_4_2.eContents().get(0);
		private final Assignment cSuperPatternsAssignment_4_2_1 = (Assignment)cGroup_4_2.eContents().get(1);
		private final CrossReference cSuperPatternsEditorPatternCrossReference_4_2_1_0 = (CrossReference)cSuperPatternsAssignment_4_2_1.eContents().get(0);
		private final RuleCall cSuperPatternsEditorPatternIDTerminalRuleCall_4_2_1_0_1 = (RuleCall)cSuperPatternsEditorPatternCrossReference_4_2_1_0.eContents().get(1);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cLeftCurlyBracketKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Alternatives cAlternatives_5_1 = (Alternatives)cGroup_5.eContents().get(1);
		private final Assignment cNodesAssignment_5_1_0 = (Assignment)cAlternatives_5_1.eContents().get(0);
		private final RuleCall cNodesEditorNodeParserRuleCall_5_1_0_0 = (RuleCall)cNodesAssignment_5_1_0.eContents().get(0);
		private final Assignment cAttributeConstraintsAssignment_5_1_1 = (Assignment)cAlternatives_5_1.eContents().get(1);
		private final RuleCall cAttributeConstraintsEditorAttributeConstraintParserRuleCall_5_1_1_0 = (RuleCall)cAttributeConstraintsAssignment_5_1_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5_2 = (Keyword)cGroup_5.eContents().get(2);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cWhenKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cConditionsAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final CrossReference cConditionsEditorConditionCrossReference_6_1_0 = (CrossReference)cConditionsAssignment_6_1.eContents().get(0);
		private final RuleCall cConditionsEditorConditionIDTerminalRuleCall_6_1_0_1 = (RuleCall)cConditionsEditorConditionCrossReference_6_1_0.eContents().get(1);
		private final Group cGroup_6_2 = (Group)cGroup_6.eContents().get(2);
		private final Keyword cVerticalLineVerticalLineKeyword_6_2_0 = (Keyword)cGroup_6_2.eContents().get(0);
		private final Assignment cConditionsAssignment_6_2_1 = (Assignment)cGroup_6_2.eContents().get(1);
		private final CrossReference cConditionsEditorConditionCrossReference_6_2_1_0 = (CrossReference)cConditionsAssignment_6_2_1.eContents().get(0);
		private final RuleCall cConditionsEditorConditionIDTerminalRuleCall_6_2_1_0_1 = (RuleCall)cConditionsEditorConditionCrossReference_6_2_1_0.eContents().get(1);
		private final Group cGroup_7 = (Group)cGroup.eContents().get(7);
		private final Assignment cStochasticAssignment_7_0 = (Assignment)cGroup_7.eContents().get(0);
		private final Keyword cStochasticCommercialAtKeyword_7_0_0 = (Keyword)cStochasticAssignment_7_0.eContents().get(0);
		private final Assignment cProbabilityAssignment_7_1 = (Assignment)cGroup_7.eContents().get(1);
		private final RuleCall cProbabilityEditorProbabilityParserRuleCall_7_1_0 = (RuleCall)cProbabilityAssignment_7_1.eContents().get(0);
		
		//EditorPattern:
		//  (abstract?='abstract')? type=EditorPatternType name=ID
		//  ('('
		//  (parameters+=EditorParameter (',' parameters+=EditorParameter)*)?
		//  ')')?
		//  ('refines' superPatterns+=[EditorPattern|ID] (',' superPatterns+=[EditorPattern|ID])*)?
		//  ('{'
		//  (nodes+=EditorNode | attributeConstraints+=EditorAttributeConstraint )*
		//  '}')?
		//  ('when' conditions+=[EditorCondition|ID] ('||' conditions+=[EditorCondition|ID])*)?
		//  (stochastic ?='@' probability = EditorProbability)?;
		@Override public ParserRule getRule() { return rule; }
		
		//(abstract?='abstract')? type=EditorPatternType name=ID
		//('('
		//(parameters+=EditorParameter (',' parameters+=EditorParameter)*)?
		//')')?
		//('refines' superPatterns+=[EditorPattern|ID] (',' superPatterns+=[EditorPattern|ID])*)?
		//('{'
		//(nodes+=EditorNode | attributeConstraints+=EditorAttributeConstraint )*
		//'}')?
		//('when' conditions+=[EditorCondition|ID] ('||' conditions+=[EditorCondition|ID])*)?
		//(stochastic ?='@' probability = EditorProbability)?
		public Group getGroup() { return cGroup; }
		
		//(abstract?='abstract')?
		public Assignment getAbstractAssignment_0() { return cAbstractAssignment_0; }
		
		//'abstract'
		public Keyword getAbstractAbstractKeyword_0_0() { return cAbstractAbstractKeyword_0_0; }
		
		//type=EditorPatternType
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }
		
		//EditorPatternType
		public RuleCall getTypeEditorPatternTypeEnumRuleCall_1_0() { return cTypeEditorPatternTypeEnumRuleCall_1_0; }
		
		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }
		
		//('('
		//(parameters+=EditorParameter (',' parameters+=EditorParameter)*)?
		//')')?
		public Group getGroup_3() { return cGroup_3; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_3_0() { return cLeftParenthesisKeyword_3_0; }
		
		//(parameters+=EditorParameter (',' parameters+=EditorParameter)*)?
		public Group getGroup_3_1() { return cGroup_3_1; }
		
		//parameters+=EditorParameter
		public Assignment getParametersAssignment_3_1_0() { return cParametersAssignment_3_1_0; }
		
		//EditorParameter
		public RuleCall getParametersEditorParameterParserRuleCall_3_1_0_0() { return cParametersEditorParameterParserRuleCall_3_1_0_0; }
		
		//(',' parameters+=EditorParameter)*
		public Group getGroup_3_1_1() { return cGroup_3_1_1; }
		
		//','
		public Keyword getCommaKeyword_3_1_1_0() { return cCommaKeyword_3_1_1_0; }
		
		//parameters+=EditorParameter
		public Assignment getParametersAssignment_3_1_1_1() { return cParametersAssignment_3_1_1_1; }
		
		//EditorParameter
		public RuleCall getParametersEditorParameterParserRuleCall_3_1_1_1_0() { return cParametersEditorParameterParserRuleCall_3_1_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3_2() { return cRightParenthesisKeyword_3_2; }
		
		//('refines' superPatterns+=[EditorPattern|ID] (',' superPatterns+=[EditorPattern|ID])*)?
		public Group getGroup_4() { return cGroup_4; }
		
		//'refines'
		public Keyword getRefinesKeyword_4_0() { return cRefinesKeyword_4_0; }
		
		//superPatterns+=[EditorPattern|ID]
		public Assignment getSuperPatternsAssignment_4_1() { return cSuperPatternsAssignment_4_1; }
		
		//[EditorPattern|ID]
		public CrossReference getSuperPatternsEditorPatternCrossReference_4_1_0() { return cSuperPatternsEditorPatternCrossReference_4_1_0; }
		
		//ID
		public RuleCall getSuperPatternsEditorPatternIDTerminalRuleCall_4_1_0_1() { return cSuperPatternsEditorPatternIDTerminalRuleCall_4_1_0_1; }
		
		//(',' superPatterns+=[EditorPattern|ID])*
		public Group getGroup_4_2() { return cGroup_4_2; }
		
		//','
		public Keyword getCommaKeyword_4_2_0() { return cCommaKeyword_4_2_0; }
		
		//superPatterns+=[EditorPattern|ID]
		public Assignment getSuperPatternsAssignment_4_2_1() { return cSuperPatternsAssignment_4_2_1; }
		
		//[EditorPattern|ID]
		public CrossReference getSuperPatternsEditorPatternCrossReference_4_2_1_0() { return cSuperPatternsEditorPatternCrossReference_4_2_1_0; }
		
		//ID
		public RuleCall getSuperPatternsEditorPatternIDTerminalRuleCall_4_2_1_0_1() { return cSuperPatternsEditorPatternIDTerminalRuleCall_4_2_1_0_1; }
		
		//('{'
		//(nodes+=EditorNode | attributeConstraints+=EditorAttributeConstraint )*
		//'}')?
		public Group getGroup_5() { return cGroup_5; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_5_0() { return cLeftCurlyBracketKeyword_5_0; }
		
		//(nodes+=EditorNode | attributeConstraints+=EditorAttributeConstraint )*
		public Alternatives getAlternatives_5_1() { return cAlternatives_5_1; }
		
		//nodes+=EditorNode
		public Assignment getNodesAssignment_5_1_0() { return cNodesAssignment_5_1_0; }
		
		//EditorNode
		public RuleCall getNodesEditorNodeParserRuleCall_5_1_0_0() { return cNodesEditorNodeParserRuleCall_5_1_0_0; }
		
		//attributeConstraints+=EditorAttributeConstraint
		public Assignment getAttributeConstraintsAssignment_5_1_1() { return cAttributeConstraintsAssignment_5_1_1; }
		
		//EditorAttributeConstraint
		public RuleCall getAttributeConstraintsEditorAttributeConstraintParserRuleCall_5_1_1_0() { return cAttributeConstraintsEditorAttributeConstraintParserRuleCall_5_1_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_5_2() { return cRightCurlyBracketKeyword_5_2; }
		
		//('when' conditions+=[EditorCondition|ID] ('||' conditions+=[EditorCondition|ID])*)?
		public Group getGroup_6() { return cGroup_6; }
		
		//'when'
		public Keyword getWhenKeyword_6_0() { return cWhenKeyword_6_0; }
		
		//conditions+=[EditorCondition|ID]
		public Assignment getConditionsAssignment_6_1() { return cConditionsAssignment_6_1; }
		
		//[EditorCondition|ID]
		public CrossReference getConditionsEditorConditionCrossReference_6_1_0() { return cConditionsEditorConditionCrossReference_6_1_0; }
		
		//ID
		public RuleCall getConditionsEditorConditionIDTerminalRuleCall_6_1_0_1() { return cConditionsEditorConditionIDTerminalRuleCall_6_1_0_1; }
		
		//('||' conditions+=[EditorCondition|ID])*
		public Group getGroup_6_2() { return cGroup_6_2; }
		
		//'||'
		public Keyword getVerticalLineVerticalLineKeyword_6_2_0() { return cVerticalLineVerticalLineKeyword_6_2_0; }
		
		//conditions+=[EditorCondition|ID]
		public Assignment getConditionsAssignment_6_2_1() { return cConditionsAssignment_6_2_1; }
		
		//[EditorCondition|ID]
		public CrossReference getConditionsEditorConditionCrossReference_6_2_1_0() { return cConditionsEditorConditionCrossReference_6_2_1_0; }
		
		//ID
		public RuleCall getConditionsEditorConditionIDTerminalRuleCall_6_2_1_0_1() { return cConditionsEditorConditionIDTerminalRuleCall_6_2_1_0_1; }
		
		//(stochastic ?='@' probability = EditorProbability)?
		public Group getGroup_7() { return cGroup_7; }
		
		//stochastic ?='@'
		public Assignment getStochasticAssignment_7_0() { return cStochasticAssignment_7_0; }
		
		//'@'
		public Keyword getStochasticCommercialAtKeyword_7_0_0() { return cStochasticCommercialAtKeyword_7_0_0; }
		
		//probability = EditorProbability
		public Assignment getProbabilityAssignment_7_1() { return cProbabilityAssignment_7_1; }
		
		//EditorProbability
		public RuleCall getProbabilityEditorProbabilityParserRuleCall_7_1_0() { return cProbabilityEditorProbabilityParserRuleCall_7_1_0; }
	}
	public class EditorParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.EditorParameter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cTypeEDataTypeCrossReference_2_0 = (CrossReference)cTypeAssignment_2.eContents().get(0);
		private final RuleCall cTypeEDataTypeIDTerminalRuleCall_2_0_1 = (RuleCall)cTypeEDataTypeCrossReference_2_0.eContents().get(1);
		
		//EditorParameter:
		//  name=ID ':' type=[ecore::EDataType];
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID ':' type=[ecore::EDataType]
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//type=[ecore::EDataType]
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//[ecore::EDataType]
		public CrossReference getTypeEDataTypeCrossReference_2_0() { return cTypeEDataTypeCrossReference_2_0; }
		
		//ID
		public RuleCall getTypeEDataTypeIDTerminalRuleCall_2_0_1() { return cTypeEDataTypeIDTerminalRuleCall_2_0_1; }
	}
	public class EditorNodeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.EditorNode");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOperatorAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOperatorEditorOperatorEnumRuleCall_0_0 = (RuleCall)cOperatorAssignment_0.eContents().get(0);
		private final Assignment cLocalAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cLocalLocalKeyword_1_0 = (Keyword)cLocalAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cColonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cTypeAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final CrossReference cTypeEClassCrossReference_4_0 = (CrossReference)cTypeAssignment_4.eContents().get(0);
		private final RuleCall cTypeEClassIDTerminalRuleCall_4_0_1 = (RuleCall)cTypeEClassCrossReference_4_0.eContents().get(1);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cLeftCurlyBracketKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Alternatives cAlternatives_5_1 = (Alternatives)cGroup_5.eContents().get(1);
		private final Assignment cAttributesAssignment_5_1_0 = (Assignment)cAlternatives_5_1.eContents().get(0);
		private final RuleCall cAttributesEditorAttributeAssignmentParserRuleCall_5_1_0_0 = (RuleCall)cAttributesAssignment_5_1_0.eContents().get(0);
		private final Assignment cReferencesAssignment_5_1_1 = (Assignment)cAlternatives_5_1.eContents().get(1);
		private final RuleCall cReferencesEditorReferenceParserRuleCall_5_1_1_0 = (RuleCall)cReferencesAssignment_5_1_1.eContents().get(0);
		private final Assignment cIteratorsAssignment_5_1_2 = (Assignment)cAlternatives_5_1.eContents().get(2);
		private final RuleCall cIteratorsEditorReferenceIteratorParserRuleCall_5_1_2_0 = (RuleCall)cIteratorsAssignment_5_1_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5_2 = (Keyword)cGroup_5.eContents().get(2);
		
		//  // Nodes
		//EditorNode:
		//  (operator=EditorOperator)? (local?='local')?
		//  name=ID ':' type=[ecore::EClass] ('{'
		//  (attributes+=EditorAttributeAssignment | references+=EditorReference | iterators+=EditorReferenceIterator)*
		//  '}')?;
		@Override public ParserRule getRule() { return rule; }
		
		//(operator=EditorOperator)? (local?='local')?
		//name=ID ':' type=[ecore::EClass] ('{'
		//(attributes+=EditorAttributeAssignment | references+=EditorReference | iterators+=EditorReferenceIterator)*
		//'}')?
		public Group getGroup() { return cGroup; }
		
		//(operator=EditorOperator)?
		public Assignment getOperatorAssignment_0() { return cOperatorAssignment_0; }
		
		//EditorOperator
		public RuleCall getOperatorEditorOperatorEnumRuleCall_0_0() { return cOperatorEditorOperatorEnumRuleCall_0_0; }
		
		//(local?='local')?
		public Assignment getLocalAssignment_1() { return cLocalAssignment_1; }
		
		//'local'
		public Keyword getLocalLocalKeyword_1_0() { return cLocalLocalKeyword_1_0; }
		
		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }
		
		//':'
		public Keyword getColonKeyword_3() { return cColonKeyword_3; }
		
		//type=[ecore::EClass]
		public Assignment getTypeAssignment_4() { return cTypeAssignment_4; }
		
		//[ecore::EClass]
		public CrossReference getTypeEClassCrossReference_4_0() { return cTypeEClassCrossReference_4_0; }
		
		//ID
		public RuleCall getTypeEClassIDTerminalRuleCall_4_0_1() { return cTypeEClassIDTerminalRuleCall_4_0_1; }
		
		//('{'
		// (attributes+=EditorAttributeAssignment | references+=EditorReference | iterators+=EditorReferenceIterator)*
		// '}')?
		public Group getGroup_5() { return cGroup_5; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_5_0() { return cLeftCurlyBracketKeyword_5_0; }
		
		//(attributes+=EditorAttributeAssignment | references+=EditorReference | iterators+=EditorReferenceIterator)*
		public Alternatives getAlternatives_5_1() { return cAlternatives_5_1; }
		
		//attributes+=EditorAttributeAssignment
		public Assignment getAttributesAssignment_5_1_0() { return cAttributesAssignment_5_1_0; }
		
		//EditorAttributeAssignment
		public RuleCall getAttributesEditorAttributeAssignmentParserRuleCall_5_1_0_0() { return cAttributesEditorAttributeAssignmentParserRuleCall_5_1_0_0; }
		
		//references+=EditorReference
		public Assignment getReferencesAssignment_5_1_1() { return cReferencesAssignment_5_1_1; }
		
		//EditorReference
		public RuleCall getReferencesEditorReferenceParserRuleCall_5_1_1_0() { return cReferencesEditorReferenceParserRuleCall_5_1_1_0; }
		
		//iterators+=EditorReferenceIterator
		public Assignment getIteratorsAssignment_5_1_2() { return cIteratorsAssignment_5_1_2; }
		
		//EditorReferenceIterator
		public RuleCall getIteratorsEditorReferenceIteratorParserRuleCall_5_1_2_0() { return cIteratorsEditorReferenceIteratorParserRuleCall_5_1_2_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_5_2() { return cRightCurlyBracketKeyword_5_2; }
	}
	public class EditorAttributeConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.EditorAttributeConstraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNumberSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLhsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLhsEditorExpressionParserRuleCall_1_0 = (RuleCall)cLhsAssignment_1.eContents().get(0);
		private final Assignment cRelationAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRelationEditorRelationEnumRuleCall_2_0 = (RuleCall)cRelationAssignment_2.eContents().get(0);
		private final Assignment cRhsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRhsEditorExpressionParserRuleCall_3_0 = (RuleCall)cRhsAssignment_3.eContents().get(0);
		
		//  // Attribute Assignments and Conditions
		//EditorAttributeConstraint:
		//    '#' lhs=EditorExpression relation=EditorRelation rhs=EditorExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//'#' lhs=EditorExpression relation=EditorRelation rhs=EditorExpression
		public Group getGroup() { return cGroup; }
		
		//'#'
		public Keyword getNumberSignKeyword_0() { return cNumberSignKeyword_0; }
		
		//lhs=EditorExpression
		public Assignment getLhsAssignment_1() { return cLhsAssignment_1; }
		
		//EditorExpression
		public RuleCall getLhsEditorExpressionParserRuleCall_1_0() { return cLhsEditorExpressionParserRuleCall_1_0; }
		
		//relation=EditorRelation
		public Assignment getRelationAssignment_2() { return cRelationAssignment_2; }
		
		//EditorRelation
		public RuleCall getRelationEditorRelationEnumRuleCall_2_0() { return cRelationEditorRelationEnumRuleCall_2_0; }
		
		//rhs=EditorExpression
		public Assignment getRhsAssignment_3() { return cRhsAssignment_3; }
		
		//EditorExpression
		public RuleCall getRhsEditorExpressionParserRuleCall_3_0() { return cRhsEditorExpressionParserRuleCall_3_0; }
	}
	public class EditorAttributeAssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.EditorAttributeAssignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFullStopKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cAttributeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cAttributeEAttributeCrossReference_1_0 = (CrossReference)cAttributeAssignment_1.eContents().get(0);
		private final RuleCall cAttributeEAttributeIDTerminalRuleCall_1_0_1 = (RuleCall)cAttributeEAttributeCrossReference_1_0.eContents().get(1);
		private final Keyword cColonEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cValueAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValueEditorExpressionParserRuleCall_3_0 = (RuleCall)cValueAssignment_3.eContents().get(0);
		
		//EditorAttributeAssignment:
		//    '.' attribute=[ecore::EAttribute] ':=' value=EditorExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//'.' attribute=[ecore::EAttribute] ':=' value=EditorExpression
		public Group getGroup() { return cGroup; }
		
		//'.'
		public Keyword getFullStopKeyword_0() { return cFullStopKeyword_0; }
		
		//attribute=[ecore::EAttribute]
		public Assignment getAttributeAssignment_1() { return cAttributeAssignment_1; }
		
		//[ecore::EAttribute]
		public CrossReference getAttributeEAttributeCrossReference_1_0() { return cAttributeEAttributeCrossReference_1_0; }
		
		//ID
		public RuleCall getAttributeEAttributeIDTerminalRuleCall_1_0_1() { return cAttributeEAttributeIDTerminalRuleCall_1_0_1; }
		
		//':='
		public Keyword getColonEqualsSignKeyword_2() { return cColonEqualsSignKeyword_2; }
		
		//value=EditorExpression
		public Assignment getValueAssignment_3() { return cValueAssignment_3; }
		
		//EditorExpression
		public RuleCall getValueEditorExpressionParserRuleCall_3_0() { return cValueEditorExpressionParserRuleCall_3_0; }
	}
	public class EditorExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.EditorExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cEditorEnumExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEditorParameterExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cStochasticFunctionExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cArithmeticCalculationExpressionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//EditorExpression:
		//  EditorEnumExpression |
		//  EditorParameterExpression | StochasticFunctionExpression | ArithmeticCalculationExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//EditorEnumExpression |
		//EditorParameterExpression | StochasticFunctionExpression | ArithmeticCalculationExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//EditorEnumExpression
		public RuleCall getEditorEnumExpressionParserRuleCall_0() { return cEditorEnumExpressionParserRuleCall_0; }
		
		//EditorParameterExpression
		public RuleCall getEditorParameterExpressionParserRuleCall_1() { return cEditorParameterExpressionParserRuleCall_1; }
		
		//StochasticFunctionExpression
		public RuleCall getStochasticFunctionExpressionParserRuleCall_2() { return cStochasticFunctionExpressionParserRuleCall_2; }
		
		//ArithmeticCalculationExpression
		public RuleCall getArithmeticCalculationExpressionParserRuleCall_3() { return cArithmeticCalculationExpressionParserRuleCall_3; }
	}
	public class EditorAttributeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.EditorAttributeExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNodeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cNodeEditorNodeCrossReference_0_0 = (CrossReference)cNodeAssignment_0.eContents().get(0);
		private final RuleCall cNodeEditorNodeIDTerminalRuleCall_0_0_1 = (RuleCall)cNodeEditorNodeCrossReference_0_0.eContents().get(1);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cAttributeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cAttributeEAttributeCrossReference_2_0 = (CrossReference)cAttributeAssignment_2.eContents().get(0);
		private final RuleCall cAttributeEAttributeIDTerminalRuleCall_2_0_1 = (RuleCall)cAttributeEAttributeCrossReference_2_0.eContents().get(1);
		
		//EditorAttributeExpression:
		//  node=[EditorNode|ID] '.' attribute=[ecore::EAttribute];
		@Override public ParserRule getRule() { return rule; }
		
		//node=[EditorNode|ID] '.' attribute=[ecore::EAttribute]
		public Group getGroup() { return cGroup; }
		
		//node=[EditorNode|ID]
		public Assignment getNodeAssignment_0() { return cNodeAssignment_0; }
		
		//[EditorNode|ID]
		public CrossReference getNodeEditorNodeCrossReference_0_0() { return cNodeEditorNodeCrossReference_0_0; }
		
		//ID
		public RuleCall getNodeEditorNodeIDTerminalRuleCall_0_0_1() { return cNodeEditorNodeIDTerminalRuleCall_0_0_1; }
		
		//'.'
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }
		
		//attribute=[ecore::EAttribute]
		public Assignment getAttributeAssignment_2() { return cAttributeAssignment_2; }
		
		//[ecore::EAttribute]
		public CrossReference getAttributeEAttributeCrossReference_2_0() { return cAttributeEAttributeCrossReference_2_0; }
		
		//ID
		public RuleCall getAttributeEAttributeIDTerminalRuleCall_2_0_1() { return cAttributeEAttributeIDTerminalRuleCall_2_0_1; }
	}
	public class EditorCountExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.EditorCountExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCountKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cInvokedPattenAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cInvokedPattenEditorPatternCrossReference_2_0 = (CrossReference)cInvokedPattenAssignment_2.eContents().get(0);
		private final RuleCall cInvokedPattenEditorPatternIDTerminalRuleCall_2_0_1 = (RuleCall)cInvokedPattenEditorPatternCrossReference_2_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//EditorCountExpression:
		//    'count' '(' invokedPatten = [EditorPattern|ID] ')'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'count' '(' invokedPatten = [EditorPattern|ID] ')'
		public Group getGroup() { return cGroup; }
		
		//'count'
		public Keyword getCountKeyword_0() { return cCountKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//invokedPatten = [EditorPattern|ID]
		public Assignment getInvokedPattenAssignment_2() { return cInvokedPattenAssignment_2; }
		
		//[EditorPattern|ID]
		public CrossReference getInvokedPattenEditorPatternCrossReference_2_0() { return cInvokedPattenEditorPatternCrossReference_2_0; }
		
		//ID
		public RuleCall getInvokedPattenEditorPatternIDTerminalRuleCall_2_0_1() { return cInvokedPattenEditorPatternIDTerminalRuleCall_2_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class EditorLiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.EditorLiteralExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cValueAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final Alternatives cValueAlternatives_0_0 = (Alternatives)cValueAssignment_0.eContents().get(0);
		private final Keyword cValueTrueKeyword_0_0_0 = (Keyword)cValueAlternatives_0_0.eContents().get(0);
		private final Keyword cValueFalseKeyword_0_0_1 = (Keyword)cValueAlternatives_0_0.eContents().get(1);
		private final RuleCall cValueNumberParserRuleCall_0_0_2 = (RuleCall)cValueAlternatives_0_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cStringConstantAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		
		//EditorLiteralExpression:
		//  value=('true' | 'false' | Number) |
		//  {StringConstant} value=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//value=('true' | 'false' | Number) |
		//{StringConstant} value=STRING
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//value=('true' | 'false' | Number)
		public Assignment getValueAssignment_0() { return cValueAssignment_0; }
		
		//('true' | 'false' | Number)
		public Alternatives getValueAlternatives_0_0() { return cValueAlternatives_0_0; }
		
		//'true'
		public Keyword getValueTrueKeyword_0_0_0() { return cValueTrueKeyword_0_0_0; }
		
		//'false'
		public Keyword getValueFalseKeyword_0_0_1() { return cValueFalseKeyword_0_0_1; }
		
		//Number
		public RuleCall getValueNumberParserRuleCall_0_0_2() { return cValueNumberParserRuleCall_0_0_2; }
		
		//{StringConstant} value=STRING
		public Group getGroup_1() { return cGroup_1; }
		
		//{StringConstant}
		public Action getStringConstantAction_1_0() { return cStringConstantAction_1_0; }
		
		//value=STRING
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }
		
		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_1_1_0() { return cValueSTRINGTerminalRuleCall_1_1_0; }
	}
	public class NumberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.Number");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cFullStopKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		
		//Number:
		//  ('-')? INT ('.' INT)?;
		@Override public ParserRule getRule() { return rule; }
		
		//('-')? INT ('.' INT)?
		public Group getGroup() { return cGroup; }
		
		//('-')?
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_1() { return cINTTerminalRuleCall_1; }
		
		//('.' INT)?
		public Group getGroup_2() { return cGroup_2; }
		
		//'.'
		public Keyword getFullStopKeyword_2_0() { return cFullStopKeyword_2_0; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_2_1() { return cINTTerminalRuleCall_2_1; }
	}
	public class EditorEnumExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.EditorEnumExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEnumKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLiteralAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cLiteralEEnumLiteralCrossReference_1_0 = (CrossReference)cLiteralAssignment_1.eContents().get(0);
		private final RuleCall cLiteralEEnumLiteralIDTerminalRuleCall_1_0_1 = (RuleCall)cLiteralEEnumLiteralCrossReference_1_0.eContents().get(1);
		
		//EditorEnumExpression:
		//  'enum::' literal=[ecore::EEnumLiteral];
		@Override public ParserRule getRule() { return rule; }
		
		//'enum::' literal=[ecore::EEnumLiteral]
		public Group getGroup() { return cGroup; }
		
		//'enum::'
		public Keyword getEnumKeyword_0() { return cEnumKeyword_0; }
		
		//literal=[ecore::EEnumLiteral]
		public Assignment getLiteralAssignment_1() { return cLiteralAssignment_1; }
		
		//[ecore::EEnumLiteral]
		public CrossReference getLiteralEEnumLiteralCrossReference_1_0() { return cLiteralEEnumLiteralCrossReference_1_0; }
		
		//ID
		public RuleCall getLiteralEEnumLiteralIDTerminalRuleCall_1_0_1() { return cLiteralEEnumLiteralIDTerminalRuleCall_1_0_1; }
	}
	public class EditorParameterExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.EditorParameterExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cParamKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cParameterAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cParameterEditorParameterCrossReference_1_0 = (CrossReference)cParameterAssignment_1.eContents().get(0);
		private final RuleCall cParameterEditorParameterIDTerminalRuleCall_1_0_1 = (RuleCall)cParameterEditorParameterCrossReference_1_0.eContents().get(1);
		
		//EditorParameterExpression:
		//  'param::' parameter=[EditorParameter|ID];
		@Override public ParserRule getRule() { return rule; }
		
		//'param::' parameter=[EditorParameter|ID]
		public Group getGroup() { return cGroup; }
		
		//'param::'
		public Keyword getParamKeyword_0() { return cParamKeyword_0; }
		
		//parameter=[EditorParameter|ID]
		public Assignment getParameterAssignment_1() { return cParameterAssignment_1; }
		
		//[EditorParameter|ID]
		public CrossReference getParameterEditorParameterCrossReference_1_0() { return cParameterEditorParameterCrossReference_1_0; }
		
		//ID
		public RuleCall getParameterEditorParameterIDTerminalRuleCall_1_0_1() { return cParameterEditorParameterIDTerminalRuleCall_1_0_1; }
	}
	public class EditorReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.EditorReference");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOperatorAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOperatorEditorOperatorEnumRuleCall_0_0 = (RuleCall)cOperatorAssignment_0.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cTypeEReferenceCrossReference_2_0 = (CrossReference)cTypeAssignment_2.eContents().get(0);
		private final RuleCall cTypeEReferenceIDTerminalRuleCall_2_0_1 = (RuleCall)cTypeEReferenceCrossReference_2_0.eContents().get(1);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cTargetAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final CrossReference cTargetEditorNodeCrossReference_4_0 = (CrossReference)cTargetAssignment_4.eContents().get(0);
		private final RuleCall cTargetEditorNodeIDTerminalRuleCall_4_0_1 = (RuleCall)cTargetEditorNodeCrossReference_4_0.eContents().get(1);
		
		//// References
		//EditorReference:
		//  (operator=EditorOperator)? '-' type=[ecore::EReference] '->' target=[EditorNode|ID];
		@Override public ParserRule getRule() { return rule; }
		
		//(operator=EditorOperator)? '-' type=[ecore::EReference] '->' target=[EditorNode|ID]
		public Group getGroup() { return cGroup; }
		
		//(operator=EditorOperator)?
		public Assignment getOperatorAssignment_0() { return cOperatorAssignment_0; }
		
		//EditorOperator
		public RuleCall getOperatorEditorOperatorEnumRuleCall_0_0() { return cOperatorEditorOperatorEnumRuleCall_0_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_1() { return cHyphenMinusKeyword_1; }
		
		//type=[ecore::EReference]
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//[ecore::EReference]
		public CrossReference getTypeEReferenceCrossReference_2_0() { return cTypeEReferenceCrossReference_2_0; }
		
		//ID
		public RuleCall getTypeEReferenceIDTerminalRuleCall_2_0_1() { return cTypeEReferenceIDTerminalRuleCall_2_0_1; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_3() { return cHyphenMinusGreaterThanSignKeyword_3; }
		
		//target=[EditorNode|ID]
		public Assignment getTargetAssignment_4() { return cTargetAssignment_4; }
		
		//[EditorNode|ID]
		public CrossReference getTargetEditorNodeCrossReference_4_0() { return cTargetEditorNodeCrossReference_4_0; }
		
		//ID
		public RuleCall getTargetEditorNodeIDTerminalRuleCall_4_0_1() { return cTargetEditorNodeIDTerminalRuleCall_4_0_1; }
	}
	public class EditorReferenceIteratorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.EditorReferenceIterator");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForEachKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cTypeEReferenceCrossReference_1_0 = (CrossReference)cTypeAssignment_1.eContents().get(0);
		private final RuleCall cTypeEReferenceIDTerminalRuleCall_1_0_1 = (RuleCall)cTypeEReferenceCrossReference_1_0.eContents().get(1);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameIDTerminalRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cLessThanSignKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cSubTypeAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final CrossReference cSubTypeEClassCrossReference_4_1_0 = (CrossReference)cSubTypeAssignment_4_1.eContents().get(0);
		private final RuleCall cSubTypeEClassIDTerminalRuleCall_4_1_0_1 = (RuleCall)cSubTypeEClassCrossReference_4_1_0.eContents().get(1);
		private final Keyword cGreaterThanSignKeyword_4_2 = (Keyword)cGroup_4.eContents().get(2);
		private final Keyword cLeftCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Alternatives cAlternatives_6 = (Alternatives)cGroup.eContents().get(6);
		private final Assignment cIteratorAttributesAssignment_6_0 = (Assignment)cAlternatives_6.eContents().get(0);
		private final RuleCall cIteratorAttributesEditorIteratorAttributeAssignmentParserRuleCall_6_0_0 = (RuleCall)cIteratorAttributesAssignment_6_0.eContents().get(0);
		private final Assignment cReferencesAssignment_6_1 = (Assignment)cAlternatives_6.eContents().get(1);
		private final RuleCall cReferencesEditorIteratorReferenceParserRuleCall_6_1_0 = (RuleCall)cReferencesAssignment_6_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//EditorReferenceIterator:
		//    'forEach' type=[ecore::EReference] '->' name=ID ('<'subType=[ecore::EClass]'>')? '{'
		//        (iteratorAttributes+=EditorIteratorAttributeAssignment | references+=EditorIteratorReference)+
		//    '}';
		@Override public ParserRule getRule() { return rule; }
		
		//'forEach' type=[ecore::EReference] '->' name=ID ('<'subType=[ecore::EClass]'>')? '{'
		//    (iteratorAttributes+=EditorIteratorAttributeAssignment | references+=EditorIteratorReference)+
		//'}'
		public Group getGroup() { return cGroup; }
		
		//'forEach'
		public Keyword getForEachKeyword_0() { return cForEachKeyword_0; }
		
		//type=[ecore::EReference]
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }
		
		//[ecore::EReference]
		public CrossReference getTypeEReferenceCrossReference_1_0() { return cTypeEReferenceCrossReference_1_0; }
		
		//ID
		public RuleCall getTypeEReferenceIDTerminalRuleCall_1_0_1() { return cTypeEReferenceIDTerminalRuleCall_1_0_1; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_2() { return cHyphenMinusGreaterThanSignKeyword_2; }
		
		//name=ID
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_3_0() { return cNameIDTerminalRuleCall_3_0; }
		
		//('<'subType=[ecore::EClass]'>')?
		public Group getGroup_4() { return cGroup_4; }
		
		//'<'
		public Keyword getLessThanSignKeyword_4_0() { return cLessThanSignKeyword_4_0; }
		
		//subType=[ecore::EClass]
		public Assignment getSubTypeAssignment_4_1() { return cSubTypeAssignment_4_1; }
		
		//[ecore::EClass]
		public CrossReference getSubTypeEClassCrossReference_4_1_0() { return cSubTypeEClassCrossReference_4_1_0; }
		
		//ID
		public RuleCall getSubTypeEClassIDTerminalRuleCall_4_1_0_1() { return cSubTypeEClassIDTerminalRuleCall_4_1_0_1; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_4_2() { return cGreaterThanSignKeyword_4_2; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_5() { return cLeftCurlyBracketKeyword_5; }
		
		//(iteratorAttributes+=EditorIteratorAttributeAssignment | references+=EditorIteratorReference)+
		public Alternatives getAlternatives_6() { return cAlternatives_6; }
		
		//iteratorAttributes+=EditorIteratorAttributeAssignment
		public Assignment getIteratorAttributesAssignment_6_0() { return cIteratorAttributesAssignment_6_0; }
		
		//EditorIteratorAttributeAssignment
		public RuleCall getIteratorAttributesEditorIteratorAttributeAssignmentParserRuleCall_6_0_0() { return cIteratorAttributesEditorIteratorAttributeAssignmentParserRuleCall_6_0_0; }
		
		//references+=EditorIteratorReference
		public Assignment getReferencesAssignment_6_1() { return cReferencesAssignment_6_1; }
		
		//EditorIteratorReference
		public RuleCall getReferencesEditorIteratorReferenceParserRuleCall_6_1_0() { return cReferencesEditorIteratorReferenceParserRuleCall_6_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_7() { return cRightCurlyBracketKeyword_7; }
	}
	public class EditorIteratorAttributeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.EditorIteratorAttributeExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIteratorKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cIteratorAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cIteratorEditorReferenceIteratorCrossReference_1_0 = (CrossReference)cIteratorAssignment_1.eContents().get(0);
		private final RuleCall cIteratorEditorReferenceIteratorIDTerminalRuleCall_1_0_1 = (RuleCall)cIteratorEditorReferenceIteratorCrossReference_1_0.eContents().get(1);
		private final Keyword cFullStopKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cAttributeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final CrossReference cAttributeEAttributeCrossReference_3_0 = (CrossReference)cAttributeAssignment_3.eContents().get(0);
		private final RuleCall cAttributeEAttributeIDTerminalRuleCall_3_0_1 = (RuleCall)cAttributeEAttributeCrossReference_3_0.eContents().get(1);
		
		//EditorIteratorAttributeExpression:
		//    'iterator::' iterator=[EditorReferenceIterator] '.' attribute=[ecore::EAttribute];
		@Override public ParserRule getRule() { return rule; }
		
		//'iterator::' iterator=[EditorReferenceIterator] '.' attribute=[ecore::EAttribute]
		public Group getGroup() { return cGroup; }
		
		//'iterator::'
		public Keyword getIteratorKeyword_0() { return cIteratorKeyword_0; }
		
		//iterator=[EditorReferenceIterator]
		public Assignment getIteratorAssignment_1() { return cIteratorAssignment_1; }
		
		//[EditorReferenceIterator]
		public CrossReference getIteratorEditorReferenceIteratorCrossReference_1_0() { return cIteratorEditorReferenceIteratorCrossReference_1_0; }
		
		//ID
		public RuleCall getIteratorEditorReferenceIteratorIDTerminalRuleCall_1_0_1() { return cIteratorEditorReferenceIteratorIDTerminalRuleCall_1_0_1; }
		
		//'.'
		public Keyword getFullStopKeyword_2() { return cFullStopKeyword_2; }
		
		//attribute=[ecore::EAttribute]
		public Assignment getAttributeAssignment_3() { return cAttributeAssignment_3; }
		
		//[ecore::EAttribute]
		public CrossReference getAttributeEAttributeCrossReference_3_0() { return cAttributeEAttributeCrossReference_3_0; }
		
		//ID
		public RuleCall getAttributeEAttributeIDTerminalRuleCall_3_0_1() { return cAttributeEAttributeIDTerminalRuleCall_3_0_1; }
	}
	public class EditorIteratorAttributeAssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.EditorIteratorAttributeAssignment");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cEditorIteratorAttributeAssignmentItrParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEditorIteratorAttributeAssignmentNodeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//EditorIteratorAttributeAssignment:
		//    EditorIteratorAttributeAssignmentItr | EditorIteratorAttributeAssignmentNode;
		@Override public ParserRule getRule() { return rule; }
		
		//EditorIteratorAttributeAssignmentItr | EditorIteratorAttributeAssignmentNode
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//EditorIteratorAttributeAssignmentItr
		public RuleCall getEditorIteratorAttributeAssignmentItrParserRuleCall_0() { return cEditorIteratorAttributeAssignmentItrParserRuleCall_0; }
		
		//EditorIteratorAttributeAssignmentNode
		public RuleCall getEditorIteratorAttributeAssignmentNodeParserRuleCall_1() { return cEditorIteratorAttributeAssignmentNodeParserRuleCall_1; }
	}
	public class EditorIteratorAttributeAssignmentItrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.EditorIteratorAttributeAssignmentItr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIteratorAttributeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cIteratorAttributeEditorIteratorAttributeExpressionParserRuleCall_0_0 = (RuleCall)cIteratorAttributeAssignment_0.eContents().get(0);
		private final Keyword cColonEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueEditorExpressionParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//EditorIteratorAttributeAssignmentItr:
		//     iteratorAttribute=EditorIteratorAttributeExpression ':=' value=EditorExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//iteratorAttribute=EditorIteratorAttributeExpression ':=' value=EditorExpression
		public Group getGroup() { return cGroup; }
		
		//iteratorAttribute=EditorIteratorAttributeExpression
		public Assignment getIteratorAttributeAssignment_0() { return cIteratorAttributeAssignment_0; }
		
		//EditorIteratorAttributeExpression
		public RuleCall getIteratorAttributeEditorIteratorAttributeExpressionParserRuleCall_0_0() { return cIteratorAttributeEditorIteratorAttributeExpressionParserRuleCall_0_0; }
		
		//':='
		public Keyword getColonEqualsSignKeyword_1() { return cColonEqualsSignKeyword_1; }
		
		//value=EditorExpression
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }
		
		//EditorExpression
		public RuleCall getValueEditorExpressionParserRuleCall_2_0() { return cValueEditorExpressionParserRuleCall_2_0; }
	}
	public class EditorIteratorAttributeAssignmentNodeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.EditorIteratorAttributeAssignmentNode");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNodeAttributeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNodeAttributeEditorAttributeExpressionParserRuleCall_0_0 = (RuleCall)cNodeAttributeAssignment_0.eContents().get(0);
		private final Keyword cColonEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueEditorExpressionParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//EditorIteratorAttributeAssignmentNode:
		//     nodeAttribute=EditorAttributeExpression ':=' value=EditorExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//nodeAttribute=EditorAttributeExpression ':=' value=EditorExpression
		public Group getGroup() { return cGroup; }
		
		//nodeAttribute=EditorAttributeExpression
		public Assignment getNodeAttributeAssignment_0() { return cNodeAttributeAssignment_0; }
		
		//EditorAttributeExpression
		public RuleCall getNodeAttributeEditorAttributeExpressionParserRuleCall_0_0() { return cNodeAttributeEditorAttributeExpressionParserRuleCall_0_0; }
		
		//':='
		public Keyword getColonEqualsSignKeyword_1() { return cColonEqualsSignKeyword_1; }
		
		//value=EditorExpression
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }
		
		//EditorExpression
		public RuleCall getValueEditorExpressionParserRuleCall_2_0() { return cValueEditorExpressionParserRuleCall_2_0; }
	}
	public class EditorIteratorReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.EditorIteratorReference");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOperatorAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOperatorEditorOperatorEnumRuleCall_0_0 = (RuleCall)cOperatorAssignment_0.eContents().get(0);
		private final Assignment cSourceAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cSourceEditorNodeCrossReference_1_0 = (CrossReference)cSourceAssignment_1.eContents().get(0);
		private final RuleCall cSourceEditorNodeIDTerminalRuleCall_1_0_1 = (RuleCall)cSourceEditorNodeCrossReference_1_0.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final CrossReference cTypeEReferenceCrossReference_3_0 = (CrossReference)cTypeAssignment_3.eContents().get(0);
		private final RuleCall cTypeEReferenceIDTerminalRuleCall_3_0_1 = (RuleCall)cTypeEReferenceCrossReference_3_0.eContents().get(1);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cTargetAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final CrossReference cTargetEditorReferenceIteratorCrossReference_5_0 = (CrossReference)cTargetAssignment_5.eContents().get(0);
		private final RuleCall cTargetEditorReferenceIteratorIDTerminalRuleCall_5_0_1 = (RuleCall)cTargetEditorReferenceIteratorCrossReference_5_0.eContents().get(1);
		
		//EditorIteratorReference:
		//     operator=EditorOperator source=[EditorNode|ID] '-' type=[ecore::EReference] '->' target=[EditorReferenceIterator|ID];
		@Override public ParserRule getRule() { return rule; }
		
		//operator=EditorOperator source=[EditorNode|ID] '-' type=[ecore::EReference] '->' target=[EditorReferenceIterator|ID]
		public Group getGroup() { return cGroup; }
		
		//operator=EditorOperator
		public Assignment getOperatorAssignment_0() { return cOperatorAssignment_0; }
		
		//EditorOperator
		public RuleCall getOperatorEditorOperatorEnumRuleCall_0_0() { return cOperatorEditorOperatorEnumRuleCall_0_0; }
		
		//source=[EditorNode|ID]
		public Assignment getSourceAssignment_1() { return cSourceAssignment_1; }
		
		//[EditorNode|ID]
		public CrossReference getSourceEditorNodeCrossReference_1_0() { return cSourceEditorNodeCrossReference_1_0; }
		
		//ID
		public RuleCall getSourceEditorNodeIDTerminalRuleCall_1_0_1() { return cSourceEditorNodeIDTerminalRuleCall_1_0_1; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_2() { return cHyphenMinusKeyword_2; }
		
		//type=[ecore::EReference]
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }
		
		//[ecore::EReference]
		public CrossReference getTypeEReferenceCrossReference_3_0() { return cTypeEReferenceCrossReference_3_0; }
		
		//ID
		public RuleCall getTypeEReferenceIDTerminalRuleCall_3_0_1() { return cTypeEReferenceIDTerminalRuleCall_3_0_1; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_4() { return cHyphenMinusGreaterThanSignKeyword_4; }
		
		//target=[EditorReferenceIterator|ID]
		public Assignment getTargetAssignment_5() { return cTargetAssignment_5; }
		
		//[EditorReferenceIterator|ID]
		public CrossReference getTargetEditorReferenceIteratorCrossReference_5_0() { return cTargetEditorReferenceIteratorCrossReference_5_0; }
		
		//ID
		public RuleCall getTargetEditorReferenceIteratorIDTerminalRuleCall_5_0_1() { return cTargetEditorReferenceIteratorIDTerminalRuleCall_5_0_1; }
	}
	public class EditorConditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.EditorCondition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cConditionKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cConditionsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cConditionsEditorSimpleConditionParserRuleCall_3_0 = (RuleCall)cConditionsAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cAmpersandAmpersandKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cConditionsAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cConditionsEditorSimpleConditionParserRuleCall_4_1_0 = (RuleCall)cConditionsAssignment_4_1.eContents().get(0);
		
		//// Graph Conditions
		//EditorCondition:
		//  'condition' name=ID '='
		//  conditions+=EditorSimpleCondition ('&&' conditions+=EditorSimpleCondition)*;
		@Override public ParserRule getRule() { return rule; }
		
		//'condition' name=ID '='
		//conditions+=EditorSimpleCondition ('&&' conditions+=EditorSimpleCondition)*
		public Group getGroup() { return cGroup; }
		
		//'condition'
		public Keyword getConditionKeyword_0() { return cConditionKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }
		
		//conditions+=EditorSimpleCondition
		public Assignment getConditionsAssignment_3() { return cConditionsAssignment_3; }
		
		//EditorSimpleCondition
		public RuleCall getConditionsEditorSimpleConditionParserRuleCall_3_0() { return cConditionsEditorSimpleConditionParserRuleCall_3_0; }
		
		//('&&' conditions+=EditorSimpleCondition)*
		public Group getGroup_4() { return cGroup_4; }
		
		//'&&'
		public Keyword getAmpersandAmpersandKeyword_4_0() { return cAmpersandAmpersandKeyword_4_0; }
		
		//conditions+=EditorSimpleCondition
		public Assignment getConditionsAssignment_4_1() { return cConditionsAssignment_4_1; }
		
		//EditorSimpleCondition
		public RuleCall getConditionsEditorSimpleConditionParserRuleCall_4_1_0() { return cConditionsEditorSimpleConditionParserRuleCall_4_1_0; }
	}
	public class EditorSimpleConditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.EditorSimpleCondition");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cEditorConditionReferenceAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cConditionAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final CrossReference cConditionEditorConditionCrossReference_0_1_0 = (CrossReference)cConditionAssignment_0_1.eContents().get(0);
		private final RuleCall cConditionEditorConditionIDTerminalRuleCall_0_1_0_1 = (RuleCall)cConditionEditorConditionCrossReference_0_1_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cEditorApplicationConditionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cTypeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTypeEditorApplicationConditionTypeEnumRuleCall_1_1_0 = (RuleCall)cTypeAssignment_1_1.eContents().get(0);
		private final Assignment cPatternAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final CrossReference cPatternEditorPatternCrossReference_1_2_0 = (CrossReference)cPatternAssignment_1_2.eContents().get(0);
		private final RuleCall cPatternEditorPatternIDTerminalRuleCall_1_2_0_1 = (RuleCall)cPatternEditorPatternCrossReference_1_2_0.eContents().get(1);
		
		//EditorSimpleCondition:
		//  {EditorConditionReference}
		//  condition=[EditorCondition|ID] |
		//  {EditorApplicationCondition}
		//  type=EditorApplicationConditionType pattern=[EditorPattern|ID];
		@Override public ParserRule getRule() { return rule; }
		
		//{EditorConditionReference}
		//condition=[EditorCondition|ID] |
		//{EditorApplicationCondition}
		//type=EditorApplicationConditionType pattern=[EditorPattern|ID]
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{EditorConditionReference}
		//condition=[EditorCondition|ID]
		public Group getGroup_0() { return cGroup_0; }
		
		//{EditorConditionReference}
		public Action getEditorConditionReferenceAction_0_0() { return cEditorConditionReferenceAction_0_0; }
		
		//condition=[EditorCondition|ID]
		public Assignment getConditionAssignment_0_1() { return cConditionAssignment_0_1; }
		
		//[EditorCondition|ID]
		public CrossReference getConditionEditorConditionCrossReference_0_1_0() { return cConditionEditorConditionCrossReference_0_1_0; }
		
		//ID
		public RuleCall getConditionEditorConditionIDTerminalRuleCall_0_1_0_1() { return cConditionEditorConditionIDTerminalRuleCall_0_1_0_1; }
		
		//{EditorApplicationCondition}
		//type=EditorApplicationConditionType pattern=[EditorPattern|ID]
		public Group getGroup_1() { return cGroup_1; }
		
		//{EditorApplicationCondition}
		public Action getEditorApplicationConditionAction_1_0() { return cEditorApplicationConditionAction_1_0; }
		
		//type=EditorApplicationConditionType
		public Assignment getTypeAssignment_1_1() { return cTypeAssignment_1_1; }
		
		//EditorApplicationConditionType
		public RuleCall getTypeEditorApplicationConditionTypeEnumRuleCall_1_1_0() { return cTypeEditorApplicationConditionTypeEnumRuleCall_1_1_0; }
		
		//pattern=[EditorPattern|ID]
		public Assignment getPatternAssignment_1_2() { return cPatternAssignment_1_2; }
		
		//[EditorPattern|ID]
		public CrossReference getPatternEditorPatternCrossReference_1_2_0() { return cPatternEditorPatternCrossReference_1_2_0; }
		
		//ID
		public RuleCall getPatternEditorPatternIDTerminalRuleCall_1_2_0_1() { return cPatternEditorPatternIDTerminalRuleCall_1_2_0_1; }
	}
	public class EditorProbabilityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.EditorProbability");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cStochasticFunctionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cArithmeticExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// stochastic functions
		//EditorProbability:
		//    StochasticFunction | ArithmeticExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//StochasticFunction | ArithmeticExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//StochasticFunction
		public RuleCall getStochasticFunctionParserRuleCall_0() { return cStochasticFunctionParserRuleCall_0; }
		
		//ArithmeticExpression
		public RuleCall getArithmeticExpressionParserRuleCall_1() { return cArithmeticExpressionParserRuleCall_1; }
	}
	public class StochasticFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.StochasticFunction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFunctionExpressionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cFunctionExpressionStochasticFunctionExpressionParserRuleCall_0_0 = (RuleCall)cFunctionExpressionAssignment_0.eContents().get(0);
		private final Assignment cParameterAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cParameterArithmeticExpressionParserRuleCall_1_0 = (RuleCall)cParameterAssignment_1.eContents().get(0);
		
		//StochasticFunction:
		//    functionExpression = StochasticFunctionExpression (parameter = ArithmeticExpression)?;
		@Override public ParserRule getRule() { return rule; }
		
		//functionExpression = StochasticFunctionExpression (parameter = ArithmeticExpression)?
		public Group getGroup() { return cGroup; }
		
		//functionExpression = StochasticFunctionExpression
		public Assignment getFunctionExpressionAssignment_0() { return cFunctionExpressionAssignment_0; }
		
		//StochasticFunctionExpression
		public RuleCall getFunctionExpressionStochasticFunctionExpressionParserRuleCall_0_0() { return cFunctionExpressionStochasticFunctionExpressionParserRuleCall_0_0; }
		
		//(parameter = ArithmeticExpression)?
		public Assignment getParameterAssignment_1() { return cParameterAssignment_1; }
		
		//ArithmeticExpression
		public RuleCall getParameterArithmeticExpressionParserRuleCall_1_0() { return cParameterArithmeticExpressionParserRuleCall_1_0; }
	}
	public class StochasticFunctionExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.StochasticFunctionExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOperatorRangeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOperatorRangeStochasticRangeEnumRuleCall_0_0 = (RuleCall)cOperatorRangeAssignment_0.eContents().get(0);
		private final Assignment cDistributionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDistributionStochasticDistributionEnumRuleCall_1_0 = (RuleCall)cDistributionAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cMeanAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cMeanArithmeticExpressionParserRuleCall_3_0 = (RuleCall)cMeanAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Assignment cHasSdAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final Keyword cHasSdCommaKeyword_4_0_0 = (Keyword)cHasSdAssignment_4_0.eContents().get(0);
		private final Assignment cSdAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cSdArithmeticExpressionParserRuleCall_4_1_0 = (RuleCall)cSdAssignment_4_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//StochasticFunctionExpression:
		//    (operatorRange = StochasticRange)? distribution = StochasticDistribution
		//    "(" mean = ArithmeticExpression ( hasSd ?= "," sd = ArithmeticExpression )?")";
		@Override public ParserRule getRule() { return rule; }
		
		//(operatorRange = StochasticRange)? distribution = StochasticDistribution
		//"(" mean = ArithmeticExpression ( hasSd ?= "," sd = ArithmeticExpression )?")"
		public Group getGroup() { return cGroup; }
		
		//(operatorRange = StochasticRange)?
		public Assignment getOperatorRangeAssignment_0() { return cOperatorRangeAssignment_0; }
		
		//StochasticRange
		public RuleCall getOperatorRangeStochasticRangeEnumRuleCall_0_0() { return cOperatorRangeStochasticRangeEnumRuleCall_0_0; }
		
		//distribution = StochasticDistribution
		public Assignment getDistributionAssignment_1() { return cDistributionAssignment_1; }
		
		//StochasticDistribution
		public RuleCall getDistributionStochasticDistributionEnumRuleCall_1_0() { return cDistributionStochasticDistributionEnumRuleCall_1_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//mean = ArithmeticExpression
		public Assignment getMeanAssignment_3() { return cMeanAssignment_3; }
		
		//ArithmeticExpression
		public RuleCall getMeanArithmeticExpressionParserRuleCall_3_0() { return cMeanArithmeticExpressionParserRuleCall_3_0; }
		
		//( hasSd ?= "," sd = ArithmeticExpression )?
		public Group getGroup_4() { return cGroup_4; }
		
		//hasSd ?= ","
		public Assignment getHasSdAssignment_4_0() { return cHasSdAssignment_4_0; }
		
		//","
		public Keyword getHasSdCommaKeyword_4_0_0() { return cHasSdCommaKeyword_4_0_0; }
		
		//sd = ArithmeticExpression
		public Assignment getSdAssignment_4_1() { return cSdAssignment_4_1; }
		
		//ArithmeticExpression
		public RuleCall getSdArithmeticExpressionParserRuleCall_4_1_0() { return cSdArithmeticExpressionParserRuleCall_4_1_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class ArithmeticCalculationExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.ArithmeticCalculationExpression");
		private final Assignment cExpressionAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cExpressionArithmeticExpressionParserRuleCall_0 = (RuleCall)cExpressionAssignment.eContents().get(0);
		
		//ArithmeticCalculationExpression:
		//    expression = ArithmeticExpression ;
		@Override public ParserRule getRule() { return rule; }
		
		//expression = ArithmeticExpression
		public Assignment getExpressionAssignment() { return cExpressionAssignment; }
		
		//ArithmeticExpression
		public RuleCall getExpressionArithmeticExpressionParserRuleCall_0() { return cExpressionArithmeticExpressionParserRuleCall_0; }
	}
	public class ArithmeticExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.ArithmeticExpression");
		private final RuleCall cAddExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//ArithmeticExpression:
		//    AddExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//AddExpression
		public RuleCall getAddExpressionParserRuleCall() { return cAddExpressionParserRuleCall; }
	}
	public class AddExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.AddExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAddExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cAddOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cAddOperatorAddOperatorEnumRuleCall_1_1_0 = (RuleCall)cAddOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightMultExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//AddExpression returns ArithmeticExpression:
		//    MultExpression ({AddExpression.left = current} addOperator = AddOperator right = MultExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//MultExpression ({AddExpression.left = current} addOperator = AddOperator right = MultExpression)*
		public Group getGroup() { return cGroup; }
		
		//MultExpression
		public RuleCall getMultExpressionParserRuleCall_0() { return cMultExpressionParserRuleCall_0; }
		
		//({AddExpression.left = current} addOperator = AddOperator right = MultExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{AddExpression.left = current}
		public Action getAddExpressionLeftAction_1_0() { return cAddExpressionLeftAction_1_0; }
		
		//addOperator = AddOperator
		public Assignment getAddOperatorAssignment_1_1() { return cAddOperatorAssignment_1_1; }
		
		//AddOperator
		public RuleCall getAddOperatorAddOperatorEnumRuleCall_1_1_0() { return cAddOperatorAddOperatorEnumRuleCall_1_1_0; }
		
		//right = MultExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//MultExpression
		public RuleCall getRightMultExpressionParserRuleCall_1_2_0() { return cRightMultExpressionParserRuleCall_1_2_0; }
	}
	public class MultExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.MultExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExpExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMultExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cMultOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cMultOperatorMultOperatorEnumRuleCall_1_1_0 = (RuleCall)cMultOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//MultExpression returns ArithmeticExpression:
		//    ExpExpression ({MultExpression.left = current}
		//        multOperator = MultOperator right = ExpExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//ExpExpression ({MultExpression.left = current}
		//    multOperator = MultOperator right = ExpExpression)*
		public Group getGroup() { return cGroup; }
		
		//ExpExpression
		public RuleCall getExpExpressionParserRuleCall_0() { return cExpExpressionParserRuleCall_0; }
		
		//({MultExpression.left = current}
		//       multOperator = MultOperator right = ExpExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{MultExpression.left = current}
		public Action getMultExpressionLeftAction_1_0() { return cMultExpressionLeftAction_1_0; }
		
		//multOperator = MultOperator
		public Assignment getMultOperatorAssignment_1_1() { return cMultOperatorAssignment_1_1; }
		
		//MultOperator
		public RuleCall getMultOperatorMultOperatorEnumRuleCall_1_1_0() { return cMultOperatorMultOperatorEnumRuleCall_1_1_0; }
		
		//right = ExpExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//ExpExpression
		public RuleCall getRightExpExpressionParserRuleCall_1_2_0() { return cRightExpExpressionParserRuleCall_1_2_0; }
	}
	public class ExpExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.ExpExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cMinMaxExpressionParserRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cOneParameterArithmeticsParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cExpExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cCircumflexAccentKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final Alternatives cRightAlternatives_1_2_0 = (Alternatives)cRightAssignment_1_2.eContents().get(0);
		private final RuleCall cRightMinMaxExpressionParserRuleCall_1_2_0_0 = (RuleCall)cRightAlternatives_1_2_0.eContents().get(0);
		private final RuleCall cRightOneParameterArithmeticsParserRuleCall_1_2_0_1 = (RuleCall)cRightAlternatives_1_2_0.eContents().get(1);
		
		//ExpExpression returns ArithmeticExpression:
		//    (MinMaxExpression | OneParameterArithmetics) ({ExpExpression.left = current} "^" right = (MinMaxExpression | OneParameterArithmetics))*;
		@Override public ParserRule getRule() { return rule; }
		
		//(MinMaxExpression | OneParameterArithmetics) ({ExpExpression.left = current} "^" right = (MinMaxExpression | OneParameterArithmetics))*
		public Group getGroup() { return cGroup; }
		
		//(MinMaxExpression | OneParameterArithmetics)
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//MinMaxExpression
		public RuleCall getMinMaxExpressionParserRuleCall_0_0() { return cMinMaxExpressionParserRuleCall_0_0; }
		
		//OneParameterArithmetics
		public RuleCall getOneParameterArithmeticsParserRuleCall_0_1() { return cOneParameterArithmeticsParserRuleCall_0_1; }
		
		//({ExpExpression.left = current} "^" right = (MinMaxExpression | OneParameterArithmetics))*
		public Group getGroup_1() { return cGroup_1; }
		
		//{ExpExpression.left = current}
		public Action getExpExpressionLeftAction_1_0() { return cExpExpressionLeftAction_1_0; }
		
		//"^"
		public Keyword getCircumflexAccentKeyword_1_1() { return cCircumflexAccentKeyword_1_1; }
		
		//right = (MinMaxExpression | OneParameterArithmetics)
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//(MinMaxExpression | OneParameterArithmetics)
		public Alternatives getRightAlternatives_1_2_0() { return cRightAlternatives_1_2_0; }
		
		//MinMaxExpression
		public RuleCall getRightMinMaxExpressionParserRuleCall_1_2_0_0() { return cRightMinMaxExpressionParserRuleCall_1_2_0_0; }
		
		//OneParameterArithmetics
		public RuleCall getRightOneParameterArithmeticsParserRuleCall_1_2_0_1() { return cRightOneParameterArithmeticsParserRuleCall_1_2_0_1; }
	}
	public class MinMaxExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.MinMaxExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cMinMaxExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cMinMaxOperatorAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cMinMaxOperatorMinMaxOperatorEnumRuleCall_1_0 = (RuleCall)cMinMaxOperatorAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cLeftAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cLeftArithmeticExpressionParserRuleCall_3_0 = (RuleCall)cLeftAssignment_3.eContents().get(0);
		private final Keyword cCommaKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cRightAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cRightArithmeticExpressionParserRuleCall_5_0 = (RuleCall)cRightAssignment_5.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//MinMaxExpression returns ArithmeticExpression:
		//    {MinMaxExpression} minMaxOperator = MinMaxOperator '(' left = ArithmeticExpression "," right = ArithmeticExpression ')';
		@Override public ParserRule getRule() { return rule; }
		
		//{MinMaxExpression} minMaxOperator = MinMaxOperator '(' left = ArithmeticExpression "," right = ArithmeticExpression ')'
		public Group getGroup() { return cGroup; }
		
		//{MinMaxExpression}
		public Action getMinMaxExpressionAction_0() { return cMinMaxExpressionAction_0; }
		
		//minMaxOperator = MinMaxOperator
		public Assignment getMinMaxOperatorAssignment_1() { return cMinMaxOperatorAssignment_1; }
		
		//MinMaxOperator
		public RuleCall getMinMaxOperatorMinMaxOperatorEnumRuleCall_1_0() { return cMinMaxOperatorMinMaxOperatorEnumRuleCall_1_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//left = ArithmeticExpression
		public Assignment getLeftAssignment_3() { return cLeftAssignment_3; }
		
		//ArithmeticExpression
		public RuleCall getLeftArithmeticExpressionParserRuleCall_3_0() { return cLeftArithmeticExpressionParserRuleCall_3_0; }
		
		//","
		public Keyword getCommaKeyword_4() { return cCommaKeyword_4; }
		
		//right = ArithmeticExpression
		public Assignment getRightAssignment_5() { return cRightAssignment_5; }
		
		//ArithmeticExpression
		public RuleCall getRightArithmeticExpressionParserRuleCall_5_0() { return cRightArithmeticExpressionParserRuleCall_5_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_6() { return cRightParenthesisKeyword_6; }
	}
	public class OneParameterArithmeticsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.OneParameterArithmetics");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cOneParameterArithmeticsAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cNegativeAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final Keyword cNegativeHyphenMinusKeyword_0_1_0 = (Keyword)cNegativeAssignment_0_1.eContents().get(0);
		private final Assignment cOperatorAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cOperatorOneParameterOperatorEnumRuleCall_0_2_0 = (RuleCall)cOperatorAssignment_0_2.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_3 = (Keyword)cGroup_0.eContents().get(3);
		private final Assignment cExpressionAssignment_0_4 = (Assignment)cGroup_0.eContents().get(4);
		private final RuleCall cExpressionArithmeticExpressionParserRuleCall_0_4_0 = (RuleCall)cExpressionAssignment_0_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_0_5 = (Keyword)cGroup_0.eContents().get(5);
		private final RuleCall cArithmeticAttributeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//OneParameterArithmetics returns ArithmeticExpression: {OneParameterArithmetics}
		//    (negative?="-")? (operator = OneParameterOperator)? "("expression = ArithmeticExpression ")"
		//    | ArithmeticAttribute;
		@Override public ParserRule getRule() { return rule; }
		
		//{OneParameterArithmetics}
		//   (negative?="-")? (operator = OneParameterOperator)? "("expression = ArithmeticExpression ")"
		//   | ArithmeticAttribute
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{OneParameterArithmetics}
		//   (negative?="-")? (operator = OneParameterOperator)? "("expression = ArithmeticExpression ")"
		public Group getGroup_0() { return cGroup_0; }
		
		//{OneParameterArithmetics}
		public Action getOneParameterArithmeticsAction_0_0() { return cOneParameterArithmeticsAction_0_0; }
		
		//(negative?="-")?
		public Assignment getNegativeAssignment_0_1() { return cNegativeAssignment_0_1; }
		
		//"-"
		public Keyword getNegativeHyphenMinusKeyword_0_1_0() { return cNegativeHyphenMinusKeyword_0_1_0; }
		
		//(operator = OneParameterOperator)?
		public Assignment getOperatorAssignment_0_2() { return cOperatorAssignment_0_2; }
		
		//OneParameterOperator
		public RuleCall getOperatorOneParameterOperatorEnumRuleCall_0_2_0() { return cOperatorOneParameterOperatorEnumRuleCall_0_2_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_0_3() { return cLeftParenthesisKeyword_0_3; }
		
		//expression = ArithmeticExpression
		public Assignment getExpressionAssignment_0_4() { return cExpressionAssignment_0_4; }
		
		//ArithmeticExpression
		public RuleCall getExpressionArithmeticExpressionParserRuleCall_0_4_0() { return cExpressionArithmeticExpressionParserRuleCall_0_4_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_0_5() { return cRightParenthesisKeyword_0_5; }
		
		//ArithmeticAttribute
		public RuleCall getArithmeticAttributeParserRuleCall_1() { return cArithmeticAttributeParserRuleCall_1; }
	}
	public class ArithmeticAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.ArithmeticAttribute");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cEditorLiteralExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEditorAttributeExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cEditorIteratorAttributeExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cEditorCountExpressionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//ArithmeticAttribute returns ArithmeticExpression:
		//    EditorLiteralExpression |
		//    EditorAttributeExpression |
		//    EditorIteratorAttributeExpression |
		//    EditorCountExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//EditorLiteralExpression |
		//EditorAttributeExpression |
		//EditorIteratorAttributeExpression |
		//EditorCountExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//EditorLiteralExpression
		public RuleCall getEditorLiteralExpressionParserRuleCall_0() { return cEditorLiteralExpressionParserRuleCall_0; }
		
		//EditorAttributeExpression
		public RuleCall getEditorAttributeExpressionParserRuleCall_1() { return cEditorAttributeExpressionParserRuleCall_1; }
		
		//EditorIteratorAttributeExpression
		public RuleCall getEditorIteratorAttributeExpressionParserRuleCall_2() { return cEditorIteratorAttributeExpressionParserRuleCall_2; }
		
		//EditorCountExpression
		public RuleCall getEditorCountExpressionParserRuleCall_3() { return cEditorCountExpressionParserRuleCall_3; }
	}
	
	public class EditorPatternTypeElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.EditorPatternType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cPATTERNEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cPATTERNPatternKeyword_0_0 = (Keyword)cPATTERNEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cRULEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cRULERuleKeyword_1_0 = (Keyword)cRULEEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum EditorPatternType:
		//  PATTERN='pattern' |
		//  RULE='rule';
		public EnumRule getRule() { return rule; }
		
		//PATTERN='pattern' |
		//RULE='rule'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//PATTERN='pattern'
		public EnumLiteralDeclaration getPATTERNEnumLiteralDeclaration_0() { return cPATTERNEnumLiteralDeclaration_0; }
		
		//'pattern'
		public Keyword getPATTERNPatternKeyword_0_0() { return cPATTERNPatternKeyword_0_0; }
		
		//RULE='rule'
		public EnumLiteralDeclaration getRULEEnumLiteralDeclaration_1() { return cRULEEnumLiteralDeclaration_1; }
		
		//'rule'
		public Keyword getRULERuleKeyword_1_0() { return cRULERuleKeyword_1_0; }
	}
	public class EditorOperatorElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.EditorOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cCONTEXTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cCONTEXTContextKeyword_0_0 = (Keyword)cCONTEXTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cCREATEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cCREATEPlusSignPlusSignKeyword_1_0 = (Keyword)cCREATEEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cDELETEEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cDELETEHyphenMinusHyphenMinusKeyword_2_0 = (Keyword)cDELETEEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum EditorOperator:
		//  CONTEXT='$context' |
		//  CREATE='++' |
		//  DELETE='--';
		public EnumRule getRule() { return rule; }
		
		//CONTEXT='$context' |
		//CREATE='++' |
		//DELETE='--'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//CONTEXT='$context'
		public EnumLiteralDeclaration getCONTEXTEnumLiteralDeclaration_0() { return cCONTEXTEnumLiteralDeclaration_0; }
		
		//'$context'
		public Keyword getCONTEXTContextKeyword_0_0() { return cCONTEXTContextKeyword_0_0; }
		
		//CREATE='++'
		public EnumLiteralDeclaration getCREATEEnumLiteralDeclaration_1() { return cCREATEEnumLiteralDeclaration_1; }
		
		//'++'
		public Keyword getCREATEPlusSignPlusSignKeyword_1_0() { return cCREATEPlusSignPlusSignKeyword_1_0; }
		
		//DELETE='--'
		public EnumLiteralDeclaration getDELETEEnumLiteralDeclaration_2() { return cDELETEEnumLiteralDeclaration_2; }
		
		//'--'
		public Keyword getDELETEHyphenMinusHyphenMinusKeyword_2_0() { return cDELETEHyphenMinusHyphenMinusKeyword_2_0; }
	}
	public class EditorRelationElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.EditorRelation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cGREATEREnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cGREATERGreaterThanSignKeyword_0_0 = (Keyword)cGREATEREnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cGREATER_OR_EQUALEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_1_0 = (Keyword)cGREATER_OR_EQUALEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cEQUALEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cEQUALEqualsSignEqualsSignKeyword_2_0 = (Keyword)cEQUALEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cUNEQUALEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cUNEQUALExclamationMarkEqualsSignKeyword_3_0 = (Keyword)cUNEQUALEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cSMALLER_OR_EQUALEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cSMALLER_OR_EQUALLessThanSignEqualsSignKeyword_4_0 = (Keyword)cSMALLER_OR_EQUALEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cSMALLEREnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cSMALLERLessThanSignKeyword_5_0 = (Keyword)cSMALLEREnumLiteralDeclaration_5.eContents().get(0);
		
		//enum EditorRelation:
		//  GREATER='>' |
		//  GREATER_OR_EQUAL='>=' |
		//  EQUAL='==' |
		//  UNEQUAL='!=' |
		//  SMALLER_OR_EQUAL='<=' |
		//  SMALLER='<';
		public EnumRule getRule() { return rule; }
		
		//GREATER='>' |
		//GREATER_OR_EQUAL='>=' |
		//EQUAL='==' |
		//UNEQUAL='!=' |
		//SMALLER_OR_EQUAL='<=' |
		//SMALLER='<'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//GREATER='>'
		public EnumLiteralDeclaration getGREATEREnumLiteralDeclaration_0() { return cGREATEREnumLiteralDeclaration_0; }
		
		//'>'
		public Keyword getGREATERGreaterThanSignKeyword_0_0() { return cGREATERGreaterThanSignKeyword_0_0; }
		
		//GREATER_OR_EQUAL='>='
		public EnumLiteralDeclaration getGREATER_OR_EQUALEnumLiteralDeclaration_1() { return cGREATER_OR_EQUALEnumLiteralDeclaration_1; }
		
		//'>='
		public Keyword getGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_1_0() { return cGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_1_0; }
		
		//EQUAL='=='
		public EnumLiteralDeclaration getEQUALEnumLiteralDeclaration_2() { return cEQUALEnumLiteralDeclaration_2; }
		
		//'=='
		public Keyword getEQUALEqualsSignEqualsSignKeyword_2_0() { return cEQUALEqualsSignEqualsSignKeyword_2_0; }
		
		//UNEQUAL='!='
		public EnumLiteralDeclaration getUNEQUALEnumLiteralDeclaration_3() { return cUNEQUALEnumLiteralDeclaration_3; }
		
		//'!='
		public Keyword getUNEQUALExclamationMarkEqualsSignKeyword_3_0() { return cUNEQUALExclamationMarkEqualsSignKeyword_3_0; }
		
		//SMALLER_OR_EQUAL='<='
		public EnumLiteralDeclaration getSMALLER_OR_EQUALEnumLiteralDeclaration_4() { return cSMALLER_OR_EQUALEnumLiteralDeclaration_4; }
		
		//'<='
		public Keyword getSMALLER_OR_EQUALLessThanSignEqualsSignKeyword_4_0() { return cSMALLER_OR_EQUALLessThanSignEqualsSignKeyword_4_0; }
		
		//SMALLER='<'
		public EnumLiteralDeclaration getSMALLEREnumLiteralDeclaration_5() { return cSMALLEREnumLiteralDeclaration_5; }
		
		//'<'
		public Keyword getSMALLERLessThanSignKeyword_5_0() { return cSMALLERLessThanSignKeyword_5_0; }
	}
	public class EditorApplicationConditionTypeElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.EditorApplicationConditionType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cPOSITIVEEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cPOSITIVEEnforceKeyword_0_0 = (Keyword)cPOSITIVEEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cNEGATIVEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cNEGATIVEForbidKeyword_1_0 = (Keyword)cNEGATIVEEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum EditorApplicationConditionType:
		//  POSITIVE='enforce' |
		//  NEGATIVE='forbid';
		public EnumRule getRule() { return rule; }
		
		//POSITIVE='enforce' |
		//NEGATIVE='forbid'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//POSITIVE='enforce'
		public EnumLiteralDeclaration getPOSITIVEEnumLiteralDeclaration_0() { return cPOSITIVEEnumLiteralDeclaration_0; }
		
		//'enforce'
		public Keyword getPOSITIVEEnforceKeyword_0_0() { return cPOSITIVEEnforceKeyword_0_0; }
		
		//NEGATIVE='forbid'
		public EnumLiteralDeclaration getNEGATIVEEnumLiteralDeclaration_1() { return cNEGATIVEEnumLiteralDeclaration_1; }
		
		//'forbid'
		public Keyword getNEGATIVEForbidKeyword_1_0() { return cNEGATIVEForbidKeyword_1_0; }
	}
	public class PossibleStochasticRangesElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.PossibleStochasticRanges");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cNEUTRALEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cNEUTRALNEUTRALKeyword_0_0 = (Keyword)cNEUTRALEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cPOSITIVEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cPOSITIVEPOSITIVEKeyword_1_0 = (Keyword)cPOSITIVEEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cNEGATIVEEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cNEGATIVENEGATIVEKeyword_2_0 = (Keyword)cNEGATIVEEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum PossibleStochasticRanges:
		//    NEUTRAL | POSITIVE | NEGATIVE;
		public EnumRule getRule() { return rule; }
		
		//NEUTRAL | POSITIVE | NEGATIVE
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//NEUTRAL
		public EnumLiteralDeclaration getNEUTRALEnumLiteralDeclaration_0() { return cNEUTRALEnumLiteralDeclaration_0; }
		
		public Keyword getNEUTRALNEUTRALKeyword_0_0() { return cNEUTRALNEUTRALKeyword_0_0; }
		
		//POSITIVE
		public EnumLiteralDeclaration getPOSITIVEEnumLiteralDeclaration_1() { return cPOSITIVEEnumLiteralDeclaration_1; }
		
		public Keyword getPOSITIVEPOSITIVEKeyword_1_0() { return cPOSITIVEPOSITIVEKeyword_1_0; }
		
		//NEGATIVE
		public EnumLiteralDeclaration getNEGATIVEEnumLiteralDeclaration_2() { return cNEGATIVEEnumLiteralDeclaration_2; }
		
		public Keyword getNEGATIVENEGATIVEKeyword_2_0() { return cNEGATIVENEGATIVEKeyword_2_0; }
	}
	public class StochasticRangeElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.StochasticRange");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cPOSITIVEEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cPOSITIVEPlusSignKeyword_0_0 = (Keyword)cPOSITIVEEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cNEGATIVEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cNEGATIVEHyphenMinusKeyword_1_0 = (Keyword)cNEGATIVEEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum StochasticRange returns PossibleStochasticRanges:
		//    POSITIVE = "+" | NEGATIVE = "-";
		public EnumRule getRule() { return rule; }
		
		//POSITIVE = "+" | NEGATIVE = "-"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//POSITIVE = "+"
		public EnumLiteralDeclaration getPOSITIVEEnumLiteralDeclaration_0() { return cPOSITIVEEnumLiteralDeclaration_0; }
		
		//"+"
		public Keyword getPOSITIVEPlusSignKeyword_0_0() { return cPOSITIVEPlusSignKeyword_0_0; }
		
		//NEGATIVE = "-"
		public EnumLiteralDeclaration getNEGATIVEEnumLiteralDeclaration_1() { return cNEGATIVEEnumLiteralDeclaration_1; }
		
		//"-"
		public Keyword getNEGATIVEHyphenMinusKeyword_1_0() { return cNEGATIVEHyphenMinusKeyword_1_0; }
	}
	public class StochasticDistributionElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.StochasticDistribution");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cNORMALEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cNORMALNKeyword_0_0 = (Keyword)cNORMALEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cUNIFORMEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cUNIFORMUKeyword_1_0 = (Keyword)cUNIFORMEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cEXPONENTIALEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cEXPONENTIALExpKeyword_2_0 = (Keyword)cEXPONENTIALEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum StochasticDistribution:
		//    NORMAL = "N" | UNIFORM = "U" | EXPONENTIAL = "Exp";
		public EnumRule getRule() { return rule; }
		
		//NORMAL = "N" | UNIFORM = "U" | EXPONENTIAL = "Exp"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//NORMAL = "N"
		public EnumLiteralDeclaration getNORMALEnumLiteralDeclaration_0() { return cNORMALEnumLiteralDeclaration_0; }
		
		//"N"
		public Keyword getNORMALNKeyword_0_0() { return cNORMALNKeyword_0_0; }
		
		//UNIFORM = "U"
		public EnumLiteralDeclaration getUNIFORMEnumLiteralDeclaration_1() { return cUNIFORMEnumLiteralDeclaration_1; }
		
		//"U"
		public Keyword getUNIFORMUKeyword_1_0() { return cUNIFORMUKeyword_1_0; }
		
		//EXPONENTIAL = "Exp"
		public EnumLiteralDeclaration getEXPONENTIALEnumLiteralDeclaration_2() { return cEXPONENTIALEnumLiteralDeclaration_2; }
		
		//"Exp"
		public Keyword getEXPONENTIALExpKeyword_2_0() { return cEXPONENTIALExpKeyword_2_0; }
	}
	public class MultOperatorElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.MultOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cMULTIPLICATIONEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cMULTIPLICATIONAsteriskKeyword_0_0 = (Keyword)cMULTIPLICATIONEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDIVISIONEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDIVISIONSolidusKeyword_1_0 = (Keyword)cDIVISIONEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cMODULOEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cMODULOPercentSignKeyword_2_0 = (Keyword)cMODULOEnumLiteralDeclaration_2.eContents().get(0);
		
		////arithmetic functions
		//enum MultOperator:
		//    MULTIPLICATION = "*" | DIVISION = "/" | MODULO = "%";
		public EnumRule getRule() { return rule; }
		
		//MULTIPLICATION = "*" | DIVISION = "/" | MODULO = "%"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//MULTIPLICATION = "*"
		public EnumLiteralDeclaration getMULTIPLICATIONEnumLiteralDeclaration_0() { return cMULTIPLICATIONEnumLiteralDeclaration_0; }
		
		//"*"
		public Keyword getMULTIPLICATIONAsteriskKeyword_0_0() { return cMULTIPLICATIONAsteriskKeyword_0_0; }
		
		//DIVISION = "/"
		public EnumLiteralDeclaration getDIVISIONEnumLiteralDeclaration_1() { return cDIVISIONEnumLiteralDeclaration_1; }
		
		//"/"
		public Keyword getDIVISIONSolidusKeyword_1_0() { return cDIVISIONSolidusKeyword_1_0; }
		
		//MODULO = "%"
		public EnumLiteralDeclaration getMODULOEnumLiteralDeclaration_2() { return cMODULOEnumLiteralDeclaration_2; }
		
		//"%"
		public Keyword getMODULOPercentSignKeyword_2_0() { return cMODULOPercentSignKeyword_2_0; }
	}
	public class MinMaxOperatorElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.MinMaxOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cMINEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cMINMinKeyword_0_0 = (Keyword)cMINEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMAXEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMAXMaxKeyword_1_0 = (Keyword)cMAXEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum MinMaxOperator:
		//    MIN = "min" | MAX = "max"
		//;
		public EnumRule getRule() { return rule; }
		
		//MIN = "min" | MAX = "max"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//MIN = "min"
		public EnumLiteralDeclaration getMINEnumLiteralDeclaration_0() { return cMINEnumLiteralDeclaration_0; }
		
		//"min"
		public Keyword getMINMinKeyword_0_0() { return cMINMinKeyword_0_0; }
		
		//MAX = "max"
		public EnumLiteralDeclaration getMAXEnumLiteralDeclaration_1() { return cMAXEnumLiteralDeclaration_1; }
		
		//"max"
		public Keyword getMAXMaxKeyword_1_0() { return cMAXMaxKeyword_1_0; }
	}
	public class AddOperatorElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.AddOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cADDITIONEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cADDITIONPlusSignKeyword_0_0 = (Keyword)cADDITIONEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cSUBTRACTIONEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cSUBTRACTIONHyphenMinusKeyword_1_0 = (Keyword)cSUBTRACTIONEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum AddOperator:
		//    ADDITION = "+" | SUBTRACTION ="-";
		public EnumRule getRule() { return rule; }
		
		//ADDITION = "+" | SUBTRACTION ="-"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ADDITION = "+"
		public EnumLiteralDeclaration getADDITIONEnumLiteralDeclaration_0() { return cADDITIONEnumLiteralDeclaration_0; }
		
		//"+"
		public Keyword getADDITIONPlusSignKeyword_0_0() { return cADDITIONPlusSignKeyword_0_0; }
		
		//SUBTRACTION ="-"
		public EnumLiteralDeclaration getSUBTRACTIONEnumLiteralDeclaration_1() { return cSUBTRACTIONEnumLiteralDeclaration_1; }
		
		//"-"
		public Keyword getSUBTRACTIONHyphenMinusKeyword_1_0() { return cSUBTRACTIONHyphenMinusKeyword_1_0; }
	}
	public class AllOneParameterOperatorsElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.AllOneParameterOperators");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cBRACKETEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cBRACKETBRACKETKeyword_0_0 = (Keyword)cBRACKETEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cROOTEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cROOTROOTKeyword_1_0 = (Keyword)cROOTEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cABSOLUTEEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cABSOLUTEABSOLUTEKeyword_2_0 = (Keyword)cABSOLUTEEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cSINEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cSINSINKeyword_3_0 = (Keyword)cSINEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cCOSEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cCOSCOSKeyword_4_0 = (Keyword)cCOSEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cTANEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cTANTANKeyword_5_0 = (Keyword)cTANEnumLiteralDeclaration_5.eContents().get(0);
		private final EnumLiteralDeclaration cE_EXPONENTIALEnumLiteralDeclaration_6 = (EnumLiteralDeclaration)cAlternatives.eContents().get(6);
		private final Keyword cE_EXPONENTIALE_EXPONENTIALKeyword_6_0 = (Keyword)cE_EXPONENTIALEnumLiteralDeclaration_6.eContents().get(0);
		private final EnumLiteralDeclaration cLOGARITHMUSEnumLiteralDeclaration_7 = (EnumLiteralDeclaration)cAlternatives.eContents().get(7);
		private final Keyword cLOGARITHMUSLOGARITHMUSKeyword_7_0 = (Keyword)cLOGARITHMUSEnumLiteralDeclaration_7.eContents().get(0);
		private final EnumLiteralDeclaration cNAT_LOGEnumLiteralDeclaration_8 = (EnumLiteralDeclaration)cAlternatives.eContents().get(8);
		private final Keyword cNAT_LOGNAT_LOGKeyword_8_0 = (Keyword)cNAT_LOGEnumLiteralDeclaration_8.eContents().get(0);
		
		//enum AllOneParameterOperators:
		//    BRACKET | ROOT | ABSOLUTE | SIN | COS | TAN | E_EXPONENTIAL | LOGARITHMUS | NAT_LOG;
		public EnumRule getRule() { return rule; }
		
		//BRACKET | ROOT | ABSOLUTE | SIN | COS | TAN | E_EXPONENTIAL | LOGARITHMUS | NAT_LOG
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//BRACKET
		public EnumLiteralDeclaration getBRACKETEnumLiteralDeclaration_0() { return cBRACKETEnumLiteralDeclaration_0; }
		
		public Keyword getBRACKETBRACKETKeyword_0_0() { return cBRACKETBRACKETKeyword_0_0; }
		
		//ROOT
		public EnumLiteralDeclaration getROOTEnumLiteralDeclaration_1() { return cROOTEnumLiteralDeclaration_1; }
		
		public Keyword getROOTROOTKeyword_1_0() { return cROOTROOTKeyword_1_0; }
		
		//ABSOLUTE
		public EnumLiteralDeclaration getABSOLUTEEnumLiteralDeclaration_2() { return cABSOLUTEEnumLiteralDeclaration_2; }
		
		public Keyword getABSOLUTEABSOLUTEKeyword_2_0() { return cABSOLUTEABSOLUTEKeyword_2_0; }
		
		//SIN
		public EnumLiteralDeclaration getSINEnumLiteralDeclaration_3() { return cSINEnumLiteralDeclaration_3; }
		
		public Keyword getSINSINKeyword_3_0() { return cSINSINKeyword_3_0; }
		
		//COS
		public EnumLiteralDeclaration getCOSEnumLiteralDeclaration_4() { return cCOSEnumLiteralDeclaration_4; }
		
		public Keyword getCOSCOSKeyword_4_0() { return cCOSCOSKeyword_4_0; }
		
		//TAN
		public EnumLiteralDeclaration getTANEnumLiteralDeclaration_5() { return cTANEnumLiteralDeclaration_5; }
		
		public Keyword getTANTANKeyword_5_0() { return cTANTANKeyword_5_0; }
		
		//E_EXPONENTIAL
		public EnumLiteralDeclaration getE_EXPONENTIALEnumLiteralDeclaration_6() { return cE_EXPONENTIALEnumLiteralDeclaration_6; }
		
		public Keyword getE_EXPONENTIALE_EXPONENTIALKeyword_6_0() { return cE_EXPONENTIALE_EXPONENTIALKeyword_6_0; }
		
		//LOGARITHMUS
		public EnumLiteralDeclaration getLOGARITHMUSEnumLiteralDeclaration_7() { return cLOGARITHMUSEnumLiteralDeclaration_7; }
		
		public Keyword getLOGARITHMUSLOGARITHMUSKeyword_7_0() { return cLOGARITHMUSLOGARITHMUSKeyword_7_0; }
		
		//NAT_LOG
		public EnumLiteralDeclaration getNAT_LOGEnumLiteralDeclaration_8() { return cNAT_LOGEnumLiteralDeclaration_8; }
		
		public Keyword getNAT_LOGNAT_LOGKeyword_8_0() { return cNAT_LOGNAT_LOGKeyword_8_0; }
	}
	public class OneParameterOperatorElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.emoflon.ibex.gt.editor.GT.OneParameterOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cROOTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cROOTSqrtKeyword_0_0 = (Keyword)cROOTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cABSOLUTEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cABSOLUTEAbsKeyword_1_0 = (Keyword)cABSOLUTEEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cSINEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cSINSinKeyword_2_0 = (Keyword)cSINEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cCOSEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cCOSCosKeyword_3_0 = (Keyword)cCOSEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cTANEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cTANTanKeyword_4_0 = (Keyword)cTANEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cE_EXPONENTIALEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cE_EXPONENTIALExpKeyword_5_0 = (Keyword)cE_EXPONENTIALEnumLiteralDeclaration_5.eContents().get(0);
		private final EnumLiteralDeclaration cLOGARITHMUSEnumLiteralDeclaration_6 = (EnumLiteralDeclaration)cAlternatives.eContents().get(6);
		private final Keyword cLOGARITHMUSLogKeyword_6_0 = (Keyword)cLOGARITHMUSEnumLiteralDeclaration_6.eContents().get(0);
		private final EnumLiteralDeclaration cNAT_LOGEnumLiteralDeclaration_7 = (EnumLiteralDeclaration)cAlternatives.eContents().get(7);
		private final Keyword cNAT_LOGLnKeyword_7_0 = (Keyword)cNAT_LOGEnumLiteralDeclaration_7.eContents().get(0);
		
		//enum OneParameterOperator returns AllOneParameterOperators:
		//    ROOT = "sqrt" | ABSOLUTE = "abs" | SIN = "sin" | COS = "cos" | TAN = "tan" |
		//    E_EXPONENTIAL ="exp" | LOGARITHMUS = "log" | NAT_LOG = "ln";
		public EnumRule getRule() { return rule; }
		
		//ROOT = "sqrt" | ABSOLUTE = "abs" | SIN = "sin" | COS = "cos" | TAN = "tan" |
		//E_EXPONENTIAL ="exp" | LOGARITHMUS = "log" | NAT_LOG = "ln"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ROOT = "sqrt"
		public EnumLiteralDeclaration getROOTEnumLiteralDeclaration_0() { return cROOTEnumLiteralDeclaration_0; }
		
		//"sqrt"
		public Keyword getROOTSqrtKeyword_0_0() { return cROOTSqrtKeyword_0_0; }
		
		//ABSOLUTE = "abs"
		public EnumLiteralDeclaration getABSOLUTEEnumLiteralDeclaration_1() { return cABSOLUTEEnumLiteralDeclaration_1; }
		
		//"abs"
		public Keyword getABSOLUTEAbsKeyword_1_0() { return cABSOLUTEAbsKeyword_1_0; }
		
		//SIN = "sin"
		public EnumLiteralDeclaration getSINEnumLiteralDeclaration_2() { return cSINEnumLiteralDeclaration_2; }
		
		//"sin"
		public Keyword getSINSinKeyword_2_0() { return cSINSinKeyword_2_0; }
		
		//COS = "cos"
		public EnumLiteralDeclaration getCOSEnumLiteralDeclaration_3() { return cCOSEnumLiteralDeclaration_3; }
		
		//"cos"
		public Keyword getCOSCosKeyword_3_0() { return cCOSCosKeyword_3_0; }
		
		//TAN = "tan"
		public EnumLiteralDeclaration getTANEnumLiteralDeclaration_4() { return cTANEnumLiteralDeclaration_4; }
		
		//"tan"
		public Keyword getTANTanKeyword_4_0() { return cTANTanKeyword_4_0; }
		
		//E_EXPONENTIAL ="exp"
		public EnumLiteralDeclaration getE_EXPONENTIALEnumLiteralDeclaration_5() { return cE_EXPONENTIALEnumLiteralDeclaration_5; }
		
		//"exp"
		public Keyword getE_EXPONENTIALExpKeyword_5_0() { return cE_EXPONENTIALExpKeyword_5_0; }
		
		//LOGARITHMUS = "log"
		public EnumLiteralDeclaration getLOGARITHMUSEnumLiteralDeclaration_6() { return cLOGARITHMUSEnumLiteralDeclaration_6; }
		
		//"log"
		public Keyword getLOGARITHMUSLogKeyword_6_0() { return cLOGARITHMUSLogKeyword_6_0; }
		
		//NAT_LOG = "ln"
		public EnumLiteralDeclaration getNAT_LOGEnumLiteralDeclaration_7() { return cNAT_LOGEnumLiteralDeclaration_7; }
		
		//"ln"
		public Keyword getNAT_LOGLnKeyword_7_0() { return cNAT_LOGLnKeyword_7_0; }
	}
	
	private final EditorGTFileElements pEditorGTFile;
	private final EditorParameterOrNodeElements pEditorParameterOrNode;
	private final EditorImportElements pEditorImport;
	private final EditorPatternElements pEditorPattern;
	private final EditorPatternTypeElements eEditorPatternType;
	private final EditorParameterElements pEditorParameter;
	private final EditorNodeElements pEditorNode;
	private final EditorOperatorElements eEditorOperator;
	private final EditorAttributeConstraintElements pEditorAttributeConstraint;
	private final EditorAttributeAssignmentElements pEditorAttributeAssignment;
	private final EditorRelationElements eEditorRelation;
	private final EditorExpressionElements pEditorExpression;
	private final EditorAttributeExpressionElements pEditorAttributeExpression;
	private final EditorCountExpressionElements pEditorCountExpression;
	private final EditorLiteralExpressionElements pEditorLiteralExpression;
	private final NumberElements pNumber;
	private final EditorEnumExpressionElements pEditorEnumExpression;
	private final EditorParameterExpressionElements pEditorParameterExpression;
	private final EditorReferenceElements pEditorReference;
	private final EditorReferenceIteratorElements pEditorReferenceIterator;
	private final EditorIteratorAttributeExpressionElements pEditorIteratorAttributeExpression;
	private final EditorIteratorAttributeAssignmentElements pEditorIteratorAttributeAssignment;
	private final EditorIteratorAttributeAssignmentItrElements pEditorIteratorAttributeAssignmentItr;
	private final EditorIteratorAttributeAssignmentNodeElements pEditorIteratorAttributeAssignmentNode;
	private final EditorIteratorReferenceElements pEditorIteratorReference;
	private final EditorConditionElements pEditorCondition;
	private final EditorSimpleConditionElements pEditorSimpleCondition;
	private final EditorApplicationConditionTypeElements eEditorApplicationConditionType;
	private final EditorProbabilityElements pEditorProbability;
	private final StochasticFunctionElements pStochasticFunction;
	private final StochasticFunctionExpressionElements pStochasticFunctionExpression;
	private final PossibleStochasticRangesElements ePossibleStochasticRanges;
	private final StochasticRangeElements eStochasticRange;
	private final StochasticDistributionElements eStochasticDistribution;
	private final MultOperatorElements eMultOperator;
	private final MinMaxOperatorElements eMinMaxOperator;
	private final AddOperatorElements eAddOperator;
	private final AllOneParameterOperatorsElements eAllOneParameterOperators;
	private final OneParameterOperatorElements eOneParameterOperator;
	private final ArithmeticCalculationExpressionElements pArithmeticCalculationExpression;
	private final ArithmeticExpressionElements pArithmeticExpression;
	private final AddExpressionElements pAddExpression;
	private final MultExpressionElements pMultExpression;
	private final ExpExpressionElements pExpExpression;
	private final MinMaxExpressionElements pMinMaxExpression;
	private final OneParameterArithmeticsElements pOneParameterArithmetics;
	private final ArithmeticAttributeElements pArithmeticAttribute;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public GTGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pEditorGTFile = new EditorGTFileElements();
		this.pEditorParameterOrNode = new EditorParameterOrNodeElements();
		this.pEditorImport = new EditorImportElements();
		this.pEditorPattern = new EditorPatternElements();
		this.eEditorPatternType = new EditorPatternTypeElements();
		this.pEditorParameter = new EditorParameterElements();
		this.pEditorNode = new EditorNodeElements();
		this.eEditorOperator = new EditorOperatorElements();
		this.pEditorAttributeConstraint = new EditorAttributeConstraintElements();
		this.pEditorAttributeAssignment = new EditorAttributeAssignmentElements();
		this.eEditorRelation = new EditorRelationElements();
		this.pEditorExpression = new EditorExpressionElements();
		this.pEditorAttributeExpression = new EditorAttributeExpressionElements();
		this.pEditorCountExpression = new EditorCountExpressionElements();
		this.pEditorLiteralExpression = new EditorLiteralExpressionElements();
		this.pNumber = new NumberElements();
		this.pEditorEnumExpression = new EditorEnumExpressionElements();
		this.pEditorParameterExpression = new EditorParameterExpressionElements();
		this.pEditorReference = new EditorReferenceElements();
		this.pEditorReferenceIterator = new EditorReferenceIteratorElements();
		this.pEditorIteratorAttributeExpression = new EditorIteratorAttributeExpressionElements();
		this.pEditorIteratorAttributeAssignment = new EditorIteratorAttributeAssignmentElements();
		this.pEditorIteratorAttributeAssignmentItr = new EditorIteratorAttributeAssignmentItrElements();
		this.pEditorIteratorAttributeAssignmentNode = new EditorIteratorAttributeAssignmentNodeElements();
		this.pEditorIteratorReference = new EditorIteratorReferenceElements();
		this.pEditorCondition = new EditorConditionElements();
		this.pEditorSimpleCondition = new EditorSimpleConditionElements();
		this.eEditorApplicationConditionType = new EditorApplicationConditionTypeElements();
		this.pEditorProbability = new EditorProbabilityElements();
		this.pStochasticFunction = new StochasticFunctionElements();
		this.pStochasticFunctionExpression = new StochasticFunctionExpressionElements();
		this.ePossibleStochasticRanges = new PossibleStochasticRangesElements();
		this.eStochasticRange = new StochasticRangeElements();
		this.eStochasticDistribution = new StochasticDistributionElements();
		this.eMultOperator = new MultOperatorElements();
		this.eMinMaxOperator = new MinMaxOperatorElements();
		this.eAddOperator = new AddOperatorElements();
		this.eAllOneParameterOperators = new AllOneParameterOperatorsElements();
		this.eOneParameterOperator = new OneParameterOperatorElements();
		this.pArithmeticCalculationExpression = new ArithmeticCalculationExpressionElements();
		this.pArithmeticExpression = new ArithmeticExpressionElements();
		this.pAddExpression = new AddExpressionElements();
		this.pMultExpression = new MultExpressionElements();
		this.pExpExpression = new ExpExpressionElements();
		this.pMinMaxExpression = new MinMaxExpressionElements();
		this.pOneParameterArithmetics = new OneParameterArithmeticsElements();
		this.pArithmeticAttribute = new ArithmeticAttributeElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.emoflon.ibex.gt.editor.GT".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//EditorGTFile:
	//     (imports+=EditorImport)*
	//     (patterns+=EditorPattern | conditions+=EditorCondition)*;
	public EditorGTFileElements getEditorGTFileAccess() {
		return pEditorGTFile;
	}
	
	public ParserRule getEditorGTFileRule() {
		return getEditorGTFileAccess().getRule();
	}
	
	//  // This rule serves to have a common super class for pattern parameters and editor nodes
	//EditorParameterOrNode:
	//  (EditorNode | EditorParameter);
	public EditorParameterOrNodeElements getEditorParameterOrNodeAccess() {
		return pEditorParameterOrNode;
	}
	
	public ParserRule getEditorParameterOrNodeRule() {
		return getEditorParameterOrNodeAccess().getRule();
	}
	
	//EditorImport:
	//  'import' name=STRING;
	public EditorImportElements getEditorImportAccess() {
		return pEditorImport;
	}
	
	public ParserRule getEditorImportRule() {
		return getEditorImportAccess().getRule();
	}
	
	//EditorPattern:
	//  (abstract?='abstract')? type=EditorPatternType name=ID
	//  ('('
	//  (parameters+=EditorParameter (',' parameters+=EditorParameter)*)?
	//  ')')?
	//  ('refines' superPatterns+=[EditorPattern|ID] (',' superPatterns+=[EditorPattern|ID])*)?
	//  ('{'
	//  (nodes+=EditorNode | attributeConstraints+=EditorAttributeConstraint )*
	//  '}')?
	//  ('when' conditions+=[EditorCondition|ID] ('||' conditions+=[EditorCondition|ID])*)?
	//  (stochastic ?='@' probability = EditorProbability)?;
	public EditorPatternElements getEditorPatternAccess() {
		return pEditorPattern;
	}
	
	public ParserRule getEditorPatternRule() {
		return getEditorPatternAccess().getRule();
	}
	
	//enum EditorPatternType:
	//  PATTERN='pattern' |
	//  RULE='rule';
	public EditorPatternTypeElements getEditorPatternTypeAccess() {
		return eEditorPatternType;
	}
	
	public EnumRule getEditorPatternTypeRule() {
		return getEditorPatternTypeAccess().getRule();
	}
	
	//EditorParameter:
	//  name=ID ':' type=[ecore::EDataType];
	public EditorParameterElements getEditorParameterAccess() {
		return pEditorParameter;
	}
	
	public ParserRule getEditorParameterRule() {
		return getEditorParameterAccess().getRule();
	}
	
	//  // Nodes
	//EditorNode:
	//  (operator=EditorOperator)? (local?='local')?
	//  name=ID ':' type=[ecore::EClass] ('{'
	//  (attributes+=EditorAttributeAssignment | references+=EditorReference | iterators+=EditorReferenceIterator)*
	//  '}')?;
	public EditorNodeElements getEditorNodeAccess() {
		return pEditorNode;
	}
	
	public ParserRule getEditorNodeRule() {
		return getEditorNodeAccess().getRule();
	}
	
	//enum EditorOperator:
	//  CONTEXT='$context' |
	//  CREATE='++' |
	//  DELETE='--';
	public EditorOperatorElements getEditorOperatorAccess() {
		return eEditorOperator;
	}
	
	public EnumRule getEditorOperatorRule() {
		return getEditorOperatorAccess().getRule();
	}
	
	//  // Attribute Assignments and Conditions
	//EditorAttributeConstraint:
	//    '#' lhs=EditorExpression relation=EditorRelation rhs=EditorExpression;
	public EditorAttributeConstraintElements getEditorAttributeConstraintAccess() {
		return pEditorAttributeConstraint;
	}
	
	public ParserRule getEditorAttributeConstraintRule() {
		return getEditorAttributeConstraintAccess().getRule();
	}
	
	//EditorAttributeAssignment:
	//    '.' attribute=[ecore::EAttribute] ':=' value=EditorExpression;
	public EditorAttributeAssignmentElements getEditorAttributeAssignmentAccess() {
		return pEditorAttributeAssignment;
	}
	
	public ParserRule getEditorAttributeAssignmentRule() {
		return getEditorAttributeAssignmentAccess().getRule();
	}
	
	//enum EditorRelation:
	//  GREATER='>' |
	//  GREATER_OR_EQUAL='>=' |
	//  EQUAL='==' |
	//  UNEQUAL='!=' |
	//  SMALLER_OR_EQUAL='<=' |
	//  SMALLER='<';
	public EditorRelationElements getEditorRelationAccess() {
		return eEditorRelation;
	}
	
	public EnumRule getEditorRelationRule() {
		return getEditorRelationAccess().getRule();
	}
	
	//EditorExpression:
	//  EditorEnumExpression |
	//  EditorParameterExpression | StochasticFunctionExpression | ArithmeticCalculationExpression;
	public EditorExpressionElements getEditorExpressionAccess() {
		return pEditorExpression;
	}
	
	public ParserRule getEditorExpressionRule() {
		return getEditorExpressionAccess().getRule();
	}
	
	//EditorAttributeExpression:
	//  node=[EditorNode|ID] '.' attribute=[ecore::EAttribute];
	public EditorAttributeExpressionElements getEditorAttributeExpressionAccess() {
		return pEditorAttributeExpression;
	}
	
	public ParserRule getEditorAttributeExpressionRule() {
		return getEditorAttributeExpressionAccess().getRule();
	}
	
	//EditorCountExpression:
	//    'count' '(' invokedPatten = [EditorPattern|ID] ')'
	//;
	public EditorCountExpressionElements getEditorCountExpressionAccess() {
		return pEditorCountExpression;
	}
	
	public ParserRule getEditorCountExpressionRule() {
		return getEditorCountExpressionAccess().getRule();
	}
	
	//EditorLiteralExpression:
	//  value=('true' | 'false' | Number) |
	//  {StringConstant} value=STRING;
	public EditorLiteralExpressionElements getEditorLiteralExpressionAccess() {
		return pEditorLiteralExpression;
	}
	
	public ParserRule getEditorLiteralExpressionRule() {
		return getEditorLiteralExpressionAccess().getRule();
	}
	
	//Number:
	//  ('-')? INT ('.' INT)?;
	public NumberElements getNumberAccess() {
		return pNumber;
	}
	
	public ParserRule getNumberRule() {
		return getNumberAccess().getRule();
	}
	
	//EditorEnumExpression:
	//  'enum::' literal=[ecore::EEnumLiteral];
	public EditorEnumExpressionElements getEditorEnumExpressionAccess() {
		return pEditorEnumExpression;
	}
	
	public ParserRule getEditorEnumExpressionRule() {
		return getEditorEnumExpressionAccess().getRule();
	}
	
	//EditorParameterExpression:
	//  'param::' parameter=[EditorParameter|ID];
	public EditorParameterExpressionElements getEditorParameterExpressionAccess() {
		return pEditorParameterExpression;
	}
	
	public ParserRule getEditorParameterExpressionRule() {
		return getEditorParameterExpressionAccess().getRule();
	}
	
	//// References
	//EditorReference:
	//  (operator=EditorOperator)? '-' type=[ecore::EReference] '->' target=[EditorNode|ID];
	public EditorReferenceElements getEditorReferenceAccess() {
		return pEditorReference;
	}
	
	public ParserRule getEditorReferenceRule() {
		return getEditorReferenceAccess().getRule();
	}
	
	//EditorReferenceIterator:
	//    'forEach' type=[ecore::EReference] '->' name=ID ('<'subType=[ecore::EClass]'>')? '{'
	//        (iteratorAttributes+=EditorIteratorAttributeAssignment | references+=EditorIteratorReference)+
	//    '}';
	public EditorReferenceIteratorElements getEditorReferenceIteratorAccess() {
		return pEditorReferenceIterator;
	}
	
	public ParserRule getEditorReferenceIteratorRule() {
		return getEditorReferenceIteratorAccess().getRule();
	}
	
	//EditorIteratorAttributeExpression:
	//    'iterator::' iterator=[EditorReferenceIterator] '.' attribute=[ecore::EAttribute];
	public EditorIteratorAttributeExpressionElements getEditorIteratorAttributeExpressionAccess() {
		return pEditorIteratorAttributeExpression;
	}
	
	public ParserRule getEditorIteratorAttributeExpressionRule() {
		return getEditorIteratorAttributeExpressionAccess().getRule();
	}
	
	//EditorIteratorAttributeAssignment:
	//    EditorIteratorAttributeAssignmentItr | EditorIteratorAttributeAssignmentNode;
	public EditorIteratorAttributeAssignmentElements getEditorIteratorAttributeAssignmentAccess() {
		return pEditorIteratorAttributeAssignment;
	}
	
	public ParserRule getEditorIteratorAttributeAssignmentRule() {
		return getEditorIteratorAttributeAssignmentAccess().getRule();
	}
	
	//EditorIteratorAttributeAssignmentItr:
	//     iteratorAttribute=EditorIteratorAttributeExpression ':=' value=EditorExpression;
	public EditorIteratorAttributeAssignmentItrElements getEditorIteratorAttributeAssignmentItrAccess() {
		return pEditorIteratorAttributeAssignmentItr;
	}
	
	public ParserRule getEditorIteratorAttributeAssignmentItrRule() {
		return getEditorIteratorAttributeAssignmentItrAccess().getRule();
	}
	
	//EditorIteratorAttributeAssignmentNode:
	//     nodeAttribute=EditorAttributeExpression ':=' value=EditorExpression;
	public EditorIteratorAttributeAssignmentNodeElements getEditorIteratorAttributeAssignmentNodeAccess() {
		return pEditorIteratorAttributeAssignmentNode;
	}
	
	public ParserRule getEditorIteratorAttributeAssignmentNodeRule() {
		return getEditorIteratorAttributeAssignmentNodeAccess().getRule();
	}
	
	//EditorIteratorReference:
	//     operator=EditorOperator source=[EditorNode|ID] '-' type=[ecore::EReference] '->' target=[EditorReferenceIterator|ID];
	public EditorIteratorReferenceElements getEditorIteratorReferenceAccess() {
		return pEditorIteratorReference;
	}
	
	public ParserRule getEditorIteratorReferenceRule() {
		return getEditorIteratorReferenceAccess().getRule();
	}
	
	//// Graph Conditions
	//EditorCondition:
	//  'condition' name=ID '='
	//  conditions+=EditorSimpleCondition ('&&' conditions+=EditorSimpleCondition)*;
	public EditorConditionElements getEditorConditionAccess() {
		return pEditorCondition;
	}
	
	public ParserRule getEditorConditionRule() {
		return getEditorConditionAccess().getRule();
	}
	
	//EditorSimpleCondition:
	//  {EditorConditionReference}
	//  condition=[EditorCondition|ID] |
	//  {EditorApplicationCondition}
	//  type=EditorApplicationConditionType pattern=[EditorPattern|ID];
	public EditorSimpleConditionElements getEditorSimpleConditionAccess() {
		return pEditorSimpleCondition;
	}
	
	public ParserRule getEditorSimpleConditionRule() {
		return getEditorSimpleConditionAccess().getRule();
	}
	
	//enum EditorApplicationConditionType:
	//  POSITIVE='enforce' |
	//  NEGATIVE='forbid';
	public EditorApplicationConditionTypeElements getEditorApplicationConditionTypeAccess() {
		return eEditorApplicationConditionType;
	}
	
	public EnumRule getEditorApplicationConditionTypeRule() {
		return getEditorApplicationConditionTypeAccess().getRule();
	}
	
	//// stochastic functions
	//EditorProbability:
	//    StochasticFunction | ArithmeticExpression;
	public EditorProbabilityElements getEditorProbabilityAccess() {
		return pEditorProbability;
	}
	
	public ParserRule getEditorProbabilityRule() {
		return getEditorProbabilityAccess().getRule();
	}
	
	//StochasticFunction:
	//    functionExpression = StochasticFunctionExpression (parameter = ArithmeticExpression)?;
	public StochasticFunctionElements getStochasticFunctionAccess() {
		return pStochasticFunction;
	}
	
	public ParserRule getStochasticFunctionRule() {
		return getStochasticFunctionAccess().getRule();
	}
	
	//StochasticFunctionExpression:
	//    (operatorRange = StochasticRange)? distribution = StochasticDistribution
	//    "(" mean = ArithmeticExpression ( hasSd ?= "," sd = ArithmeticExpression )?")";
	public StochasticFunctionExpressionElements getStochasticFunctionExpressionAccess() {
		return pStochasticFunctionExpression;
	}
	
	public ParserRule getStochasticFunctionExpressionRule() {
		return getStochasticFunctionExpressionAccess().getRule();
	}
	
	//enum PossibleStochasticRanges:
	//    NEUTRAL | POSITIVE | NEGATIVE;
	public PossibleStochasticRangesElements getPossibleStochasticRangesAccess() {
		return ePossibleStochasticRanges;
	}
	
	public EnumRule getPossibleStochasticRangesRule() {
		return getPossibleStochasticRangesAccess().getRule();
	}
	
	//enum StochasticRange returns PossibleStochasticRanges:
	//    POSITIVE = "+" | NEGATIVE = "-";
	public StochasticRangeElements getStochasticRangeAccess() {
		return eStochasticRange;
	}
	
	public EnumRule getStochasticRangeRule() {
		return getStochasticRangeAccess().getRule();
	}
	
	//enum StochasticDistribution:
	//    NORMAL = "N" | UNIFORM = "U" | EXPONENTIAL = "Exp";
	public StochasticDistributionElements getStochasticDistributionAccess() {
		return eStochasticDistribution;
	}
	
	public EnumRule getStochasticDistributionRule() {
		return getStochasticDistributionAccess().getRule();
	}
	
	////arithmetic functions
	//enum MultOperator:
	//    MULTIPLICATION = "*" | DIVISION = "/" | MODULO = "%";
	public MultOperatorElements getMultOperatorAccess() {
		return eMultOperator;
	}
	
	public EnumRule getMultOperatorRule() {
		return getMultOperatorAccess().getRule();
	}
	
	//enum MinMaxOperator:
	//    MIN = "min" | MAX = "max"
	//;
	public MinMaxOperatorElements getMinMaxOperatorAccess() {
		return eMinMaxOperator;
	}
	
	public EnumRule getMinMaxOperatorRule() {
		return getMinMaxOperatorAccess().getRule();
	}
	
	//enum AddOperator:
	//    ADDITION = "+" | SUBTRACTION ="-";
	public AddOperatorElements getAddOperatorAccess() {
		return eAddOperator;
	}
	
	public EnumRule getAddOperatorRule() {
		return getAddOperatorAccess().getRule();
	}
	
	//enum AllOneParameterOperators:
	//    BRACKET | ROOT | ABSOLUTE | SIN | COS | TAN | E_EXPONENTIAL | LOGARITHMUS | NAT_LOG;
	public AllOneParameterOperatorsElements getAllOneParameterOperatorsAccess() {
		return eAllOneParameterOperators;
	}
	
	public EnumRule getAllOneParameterOperatorsRule() {
		return getAllOneParameterOperatorsAccess().getRule();
	}
	
	//enum OneParameterOperator returns AllOneParameterOperators:
	//    ROOT = "sqrt" | ABSOLUTE = "abs" | SIN = "sin" | COS = "cos" | TAN = "tan" |
	//    E_EXPONENTIAL ="exp" | LOGARITHMUS = "log" | NAT_LOG = "ln";
	public OneParameterOperatorElements getOneParameterOperatorAccess() {
		return eOneParameterOperator;
	}
	
	public EnumRule getOneParameterOperatorRule() {
		return getOneParameterOperatorAccess().getRule();
	}
	
	//ArithmeticCalculationExpression:
	//    expression = ArithmeticExpression ;
	public ArithmeticCalculationExpressionElements getArithmeticCalculationExpressionAccess() {
		return pArithmeticCalculationExpression;
	}
	
	public ParserRule getArithmeticCalculationExpressionRule() {
		return getArithmeticCalculationExpressionAccess().getRule();
	}
	
	//ArithmeticExpression:
	//    AddExpression;
	public ArithmeticExpressionElements getArithmeticExpressionAccess() {
		return pArithmeticExpression;
	}
	
	public ParserRule getArithmeticExpressionRule() {
		return getArithmeticExpressionAccess().getRule();
	}
	
	//AddExpression returns ArithmeticExpression:
	//    MultExpression ({AddExpression.left = current} addOperator = AddOperator right = MultExpression)*;
	public AddExpressionElements getAddExpressionAccess() {
		return pAddExpression;
	}
	
	public ParserRule getAddExpressionRule() {
		return getAddExpressionAccess().getRule();
	}
	
	//MultExpression returns ArithmeticExpression:
	//    ExpExpression ({MultExpression.left = current}
	//        multOperator = MultOperator right = ExpExpression)*;
	public MultExpressionElements getMultExpressionAccess() {
		return pMultExpression;
	}
	
	public ParserRule getMultExpressionRule() {
		return getMultExpressionAccess().getRule();
	}
	
	//ExpExpression returns ArithmeticExpression:
	//    (MinMaxExpression | OneParameterArithmetics) ({ExpExpression.left = current} "^" right = (MinMaxExpression | OneParameterArithmetics))*;
	public ExpExpressionElements getExpExpressionAccess() {
		return pExpExpression;
	}
	
	public ParserRule getExpExpressionRule() {
		return getExpExpressionAccess().getRule();
	}
	
	//MinMaxExpression returns ArithmeticExpression:
	//    {MinMaxExpression} minMaxOperator = MinMaxOperator '(' left = ArithmeticExpression "," right = ArithmeticExpression ')';
	public MinMaxExpressionElements getMinMaxExpressionAccess() {
		return pMinMaxExpression;
	}
	
	public ParserRule getMinMaxExpressionRule() {
		return getMinMaxExpressionAccess().getRule();
	}
	
	//OneParameterArithmetics returns ArithmeticExpression: {OneParameterArithmetics}
	//    (negative?="-")? (operator = OneParameterOperator)? "("expression = ArithmeticExpression ")"
	//    | ArithmeticAttribute;
	public OneParameterArithmeticsElements getOneParameterArithmeticsAccess() {
		return pOneParameterArithmetics;
	}
	
	public ParserRule getOneParameterArithmeticsRule() {
		return getOneParameterArithmeticsAccess().getRule();
	}
	
	//ArithmeticAttribute returns ArithmeticExpression:
	//    EditorLiteralExpression |
	//    EditorAttributeExpression |
	//    EditorIteratorAttributeExpression |
	//    EditorCountExpression;
	public ArithmeticAttributeElements getArithmeticAttributeAccess() {
		return pArithmeticAttribute;
	}
	
	public ParserRule getArithmeticAttributeRule() {
		return getArithmeticAttributeAccess().getRule();
	}
	
	//terminal ID: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt: ('0'..'9')+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//            '"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"' |
	//            "'" ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|"'") )* "'"
	//        ;
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT : '/*' -> '*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS         : (' '|'\t'|'\r'|'\n')+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER: .;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
