grammar org.emoflon.ibex.tgg.integrate.Integrate with org.eclipse.xtext.common.Terminals

import "http://www.moflon.org/ide/tgg/mosl/TGG" as tgg
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate integrate "http://www.emoflon.org/ibex/tgg/integrate/Integrate"

Integrate:
	package=Package
	imports+=Import*
	conflictResolutionStrategies+=ConflictResolutionStrategy*;

Package:
	'package' name=QualifiedName;

QualifiedName:
	ID ('.' ID)*;

Import:
	'#import' rule=[tgg::Rule];

ConflictResolutionStrategy:
	name=ID':' 'solve' 'conflict' 'for' 'all' '{'
	variables+=Variable+
	'satisfies' '{'
	rule=SatisfactionRule
	'}'
	'}' 'with' resolution=Resolution;

VariableReference:
	ref=[Variable];

Variable:
	'var' name=ID '=' pipeline=Pipeline;

Pipeline:
	start=(PipelineStageSrc | PipelineStageTrg);

PipelineStageSrc:
	name='#src' '|' next=(PipelineFilterStage | PipelineEndStage);

PipelineStageTrg:
	name='#trg' '|' next=(PipelineFilterStage | PipelineEndStage);

PipelineFilterStage:
	PipelineCreatedFilterStage | PipelineDeletedFilterStage | PipelineTypeFilterStage;

PipelineCreatedFilterStage:
	name='created' '|' next=(PipelineTypeFilterStage | PipelineEndStage);

PipelineDeletedFilterStage:
	name='deleted' '|' next=(PipelineTypeFilterStage | PipelineEndStage);

PipelineTypeFilterStage:
	name='type' type=[ecore::EClassifier] '|' next=PipelineEndStage;

PipelineEndStage:
	PipelineCountStage | PipelineExistsStage;

PipelineCountStage:
	name='count';

PipelineExistsStage:
	name='exists';

SatisfactionRule:
	expression=OrExpression;

OrExpression returns Expression:
	AndExpression ({OrExpression.left=current} 'or' right+=AndExpression)*;

AndExpression returns Expression:
	BooleanExpression ({AndExpression.left=current} 'and' right+=BooleanExpression)*;

BooleanExpression:
	ComparisonExpression | VariableReference;

ComparisonExpression:
	lhs=ComparisonLiteral op=('>' | '>=' | '<' | '<=' | '==' | '!=') rhs=ComparisonLiteral;

ComparisonLiteral:
	VariableReference | LiteralValue;

LiteralValue:
	value=INT;

Resolution:
	strategy=ResolutionStrategy ('fallback' fallback=FallbackResolutionStrategy)?;

ResolutionStrategy:
	MergeAndPreserveResolutionStrategy | RevokeAdditionResolutionStrategy | RevokeDeletionResolutionStrategy |
	FallbackResolutionStrategy;

FallbackResolutionStrategy:
	PreferSourceResolutionStrategy | PreferTargetResolutionStrategy | ContinueResolutionStrategy;

MergeAndPreserveResolutionStrategy:
	name='mergeAndPreserve';

RevokeAdditionResolutionStrategy:
	name='revokeAddition';

RevokeDeletionResolutionStrategy:
	name='revokeDeletion';

PreferSourceResolutionStrategy:
	name='preferSource';

PreferTargetResolutionStrategy:
	name='preferTarget';

ContinueResolutionStrategy:
	name='continue';
