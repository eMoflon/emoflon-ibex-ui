/*
 * generated by Xtext 2.27.0
 */
package org.emoflon.ibex.tgg.tggl.validation;

import static org.emoflon.ibex.common.slimgt.util.SlimGTModelUtil.getElements;

import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EDataType;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.xtext.validation.Check;
import org.emoflon.ibex.common.slimgt.slimGT.ArithmeticLiteral;
import org.emoflon.ibex.common.slimgt.slimGT.BooleanLiteral;
import org.emoflon.ibex.common.slimgt.slimGT.Constant;
import org.emoflon.ibex.common.slimgt.slimGT.DoubleLiteral;
import org.emoflon.ibex.common.slimgt.slimGT.EnumExpression;
import org.emoflon.ibex.common.slimgt.slimGT.Import;
import org.emoflon.ibex.common.slimgt.slimGT.IntegerLiteral;
import org.emoflon.ibex.common.slimgt.slimGT.NodeAttributeExpression;
import org.emoflon.ibex.common.slimgt.slimGT.NodeExpression;
import org.emoflon.ibex.common.slimgt.slimGT.PackageReference;
import org.emoflon.ibex.common.slimgt.slimGT.PackageReferenceAlias;
import org.emoflon.ibex.common.slimgt.slimGT.SlimGTPackage;
import org.emoflon.ibex.common.slimgt.slimGT.SlimParameter;
import org.emoflon.ibex.common.slimgt.slimGT.SlimRuleAttributeAssignment;
import org.emoflon.ibex.common.slimgt.slimGT.SlimRuleEdge;
import org.emoflon.ibex.common.slimgt.slimGT.SlimRuleEdgeContext;
import org.emoflon.ibex.common.slimgt.slimGT.SlimRuleInvocation;
import org.emoflon.ibex.common.slimgt.slimGT.StringLiteral;
import org.emoflon.ibex.common.slimgt.slimGT.ValueExpression;
import org.emoflon.ibex.common.slimgt.util.SlimGTModelUtil;
import org.emoflon.ibex.common.slimgt.validation.SlimGTValidatorUtil;
import org.emoflon.ibex.tgg.tggl.tGGL.AttributeCondition;
import org.emoflon.ibex.tgg.tggl.tGGL.AttributeConditionDefinition;
import org.emoflon.ibex.tgg.tggl.tGGL.AttributeConditionDefinitionLibrary;
import org.emoflon.ibex.tgg.tggl.tGGL.CorrespondenceType;
import org.emoflon.ibex.tgg.tggl.tGGL.EditorFile;
import org.emoflon.ibex.tgg.tggl.tGGL.ExpressionOperand;
import org.emoflon.ibex.tgg.tggl.tGGL.LocalVariable;
import org.emoflon.ibex.tgg.tggl.tGGL.Schema;
import org.emoflon.ibex.tgg.tggl.tGGL.SlimRule;
import org.emoflon.ibex.tgg.tggl.tGGL.SlimRuleNode;
import org.emoflon.ibex.tgg.tggl.tGGL.SlimRuleNodeContext;
import org.emoflon.ibex.tgg.tggl.tGGL.SlimRuleNodeCreation;
import org.emoflon.ibex.tgg.tggl.tGGL.TGGCorrRule;
import org.emoflon.ibex.tgg.tggl.tGGL.TGGCorrespondenceNode;
import org.emoflon.ibex.tgg.tggl.tGGL.TGGCorrespondenceNodeContext;
import org.emoflon.ibex.tgg.tggl.tGGL.TGGCorrespondenceNodeCreation;
import org.emoflon.ibex.tgg.tggl.tGGL.TGGDomainRule;
import org.emoflon.ibex.tgg.tggl.tGGL.TGGLPackage;
import org.emoflon.ibex.tgg.tggl.tGGL.TGGLRuleRefinement;
import org.emoflon.ibex.tgg.tggl.tGGL.TGGLRuleRefinementAliased;
import org.emoflon.ibex.tgg.tggl.tGGL.TGGLRuleRefinementCorrespondenceNode;
import org.emoflon.ibex.tgg.tggl.tGGL.TGGRule;
import org.emoflon.ibex.tgg.tggl.tGGL.TGGRuleRefinementNode;
import org.emoflon.ibex.tgg.tggl.util.TGGLModelFlattener;
import org.emoflon.ibex.tgg.tggl.util.TGGLWorkspaceUtil;

import com.google.common.collect.Sets;
import com.google.common.collect.Sets.SetView;

/**
 * This class contains custom validation rules.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class TGGLValidator extends AbstractTGGLValidator {

	@Check
	public void checkRuleNameForbidden(TGGRule rule) {
		if (rule.getName() == null)
			return;

		if (SlimGTValidatorUtil.RULE_NAME_BACKLIST.contains(rule.getName())) {
			error(String.format("Rule '%s' is a java keyword or an emf class and, hence, forbidden.", rule.getName()),
					TGGLPackage.Literals.TGG_RULE__NAME);
		}
	}

	@Check
	public void checkPatternNameForbidden(SlimRule pattern) {
		if (pattern.getName() == null)
			return;

		if (SlimGTValidatorUtil.RULE_NAME_BACKLIST.contains(pattern.getName())) {
			error(String.format("Pattern '%s' is a java keyword or an emf class and, hence, forbidden.", pattern.getName()),
					TGGLPackage.Literals.SLIM_RULE__NAME);
		}
	}

	@Check
	public void checkNodeNameForbidden(SlimRuleNode node) {
		if (node.getName() == null)
			return;

		if (SlimGTValidatorUtil.NODE_NAME_BACKLIST.contains(node.getName())) {
			error(String.format("Node '%s' is a java keyword or an emf class and, hence, forbidden.", node.getName()),
					SlimGTPackage.Literals.SLIM_RULE_NODE__NAME);
		}
	}

	@Check
	public void checkCorrNodeNameForbidden(TGGCorrespondenceNode corrNode) {
		if (corrNode.getName() == null)
			return;

		if (SlimGTValidatorUtil.NODE_NAME_BACKLIST.contains(corrNode.getName())) {
			error(String.format("Node '%s' is a java keyword or an emf class and, hence, forbidden.", corrNode.getName()),
					TGGLPackage.Literals.TGG_CORRESPONDENCE_NODE__NAME);
		}
	}

	@Check
	public void checkPatternContextEdgeOnly(SlimRuleNodeContext contextNode) {
		if (SlimGTModelUtil.getContainer(contextNode, SlimRule.class) == null)
			return;

		SlimRuleNode node = (SlimRuleNode) contextNode.getContext();
		if (node == null)
			return;

		for (int i = 0; i < node.getCreatedEdges().size(); i++) {
			error("Edges of binding type 'create' are forbidden in patterns.", node, SlimGTPackage.Literals.SLIM_RULE_NODE__CREATED_EDGES, i,
					IssueCodes.INCORRECT_BINDING_EDGE_CREATE);
		}
	}

	@Check
	public void checkContextEdgeWithCreateSrcForbidden(SlimRuleNodeCreation createNode) {
		SlimRuleNode node = (SlimRuleNode) createNode.getCreation();
		if (node == null)
			return;

		for (int i = 0; i < node.getContextEdges().size(); i++) {
			// FIXME wrong error highlighting
			error(String.format("Node '%s' of binding type 'create' cannot be connected via an edge of binding type 'context'.", node.getName()),
					node, SlimGTPackage.Literals.SLIM_RULE_NODE__CREATED_EDGES, i, IssueCodes.INCORRECT_BINDING_EDGE_CONTEXT);
		}
	}

	@Check
	public void checkContextEdgeWithCreateTrgForbidden(SlimRuleEdgeContext contextEdge) {
		SlimRuleEdge edge = contextEdge.getContext();
		if (edge == null)
			return;

		SlimRuleNode targetNode = (SlimRuleNode) edge.getTarget();
		if (targetNode == null)
			return;

		if (SlimGTModelUtil.getContainer(targetNode, SlimRuleNodeCreation.class) != null) {
			error("An edge of binding type 'context' cannot point to a node of binding type 'create'.", edge,
					SlimGTPackage.Literals.SLIM_RULE_EDGE__TARGET);
		}
	}

	@Check
	public void checkUniqueRuleNames(EditorFile editorFile) {
		Map<String, List<EObject>> name2rule = new HashMap<>();

		Collection<EditorFile> allFiles = TGGLWorkspaceUtil.getAllFilesInScope(editorFile);
		for (EditorFile file : allFiles) {
			for (TGGRule rule : file.getRules())
				name2rule.computeIfAbsent(rule.getName(), k -> new LinkedList<>()).add(rule);
			for (SlimRule pattern : file.getPatterns())
				name2rule.computeIfAbsent(pattern.getName(), k -> new LinkedList<>()).add(pattern);
		}

		for (Entry<String, List<EObject>> entry : name2rule.entrySet()) {
			if (entry.getValue().size() <= 1)
				continue;

			for (EObject duplRule : entry.getValue()) {
				if (!editorFile.equals(SlimGTModelUtil.getContainer(duplRule, EditorFile.class)))
					continue;

				EAttribute nameFeature = duplRule instanceof TGGRule ? //
						TGGLPackage.Literals.TGG_RULE__NAME : //
						TGGLPackage.Literals.SLIM_RULE__NAME;
				error(String.format("A rule or pattern with name '%s' does already exist in this project.", entry.getKey()), duplRule, nameFeature);
			}
		}
	}

	@Check
	public void checkUniqueConditionDefinitionLibraryNames(EditorFile editorFile) {
		Map<String, List<AttributeConditionDefinitionLibrary>> name2lib = new HashMap<>();

		Collection<EditorFile> allFiles = TGGLWorkspaceUtil.getAllFilesInScope(editorFile);
		for (EditorFile file : allFiles) {
			for (AttributeConditionDefinitionLibrary lib : file.getLibraries())
				name2lib.computeIfAbsent(lib.getName(), k -> new LinkedList<>()).add(lib);
		}

		for (Entry<String, List<AttributeConditionDefinitionLibrary>> entry : name2lib.entrySet()) {
			if (entry.getValue().size() <= 1)
				continue;

			for (AttributeConditionDefinitionLibrary duplLib : entry.getValue()) {
				if (!editorFile.equals(SlimGTModelUtil.getContainer(duplLib, EditorFile.class)))
					continue;

				error(String.format("A library with name '%s' does already exist in this project.", entry.getKey()), duplLib,
						TGGLPackage.Literals.ATTRIBUTE_CONDITION_DEFINITION_LIBRARY__NAME);
			}
		}
	}

	@Check
	public void checkUniqueConditionDefinitionNames(AttributeConditionDefinitionLibrary library) {
		Map<String, List<AttributeConditionDefinition>> name2def = new HashMap<>();

		for (AttributeConditionDefinition def : library.getAttributeCondDefs())
			name2def.computeIfAbsent(def.getName(), k -> new LinkedList<>()).add(def);

		for (Entry<String, List<AttributeConditionDefinition>> entry : name2def.entrySet()) {
			if (entry.getValue().size() <= 1)
				continue;

			for (AttributeConditionDefinition duplDef : entry.getValue()) {
				error(String.format("An attribute condition definition with name '%s' does already exist in this library.", entry.getKey()), duplDef,
						TGGLPackage.Literals.ATTRIBUTE_CONDITION_DEFINITION__NAME);
			}
		}
	}

	@Check
	public void checkUniqueCorrTypeNames(Schema schema) {
		Map<String, List<CorrespondenceType>> name2type = new HashMap<>();

		for (CorrespondenceType type : schema.getCorrespondenceTypes())
			name2type.computeIfAbsent(type.getName(), k -> new LinkedList<>()).add(type);

		for (Entry<String, List<CorrespondenceType>> entry : name2type.entrySet()) {
			if (entry.getValue().size() <= 1)
				continue;

			for (CorrespondenceType duplType : entry.getValue()) {
				error(String.format("A correspondence type with name '%s' does already exist in this schema.", entry.getKey()), duplType,
						TGGLPackage.Literals.CORRESPONDENCE_TYPE__NAME);
			}
		}
	}

	@Check
	public void checkNoImportAliasCollisions(EditorFile editorFile) {
		List<Import> imports = editorFile.getImports();

		if (imports == null || imports.isEmpty())
			return;

		Set<String> packageNames = new HashSet<>();
		Map<String, List<PackageReferenceAlias>> alias2packageName = new HashMap<>();
		for (Import imp : imports) {
			packageNames.addAll(SlimGTModelUtil.getPackages(imp).stream() //
					.map(p -> p.getName()) //
					.toList());
			for (PackageReference packageRef : imp.getPackageAliases()) {
				if (packageRef instanceof PackageReferenceAlias alias) {
					alias2packageName.computeIfAbsent(alias.getName(), k -> new LinkedList<>()).add(alias);
				}
			}
		}

		for (Entry<String, List<PackageReferenceAlias>> entry : alias2packageName.entrySet()) {
			if (packageNames.contains(entry.getKey())) {
				for (PackageReferenceAlias alias : entry.getValue()) {
					error(String.format("Alias '%s' covers an imported package name.", entry.getKey()), alias,
							SlimGTPackage.Literals.PACKAGE_REFERENCE_ALIAS__NAME);
				}
			}

			if (entry.getValue().size() <= 1)
				continue;

			for (PackageReferenceAlias alias : entry.getValue()) {
				error(String.format("Alias '%s' is already defined.", entry.getKey()), alias, SlimGTPackage.Literals.PACKAGE_REFERENCE_ALIAS__NAME);
			}
		}
	}

	@Check
	public void checkNoRuleAliasCollisions(TGGRule rule) {
		EList<TGGLRuleRefinement> refinements = rule.getRefinements();
		if (refinements == null || refinements.isEmpty())
			return;

		Map<String, List<TGGLRuleRefinementAliased>> name2aliasedRefinement = new HashMap<>();
		for (TGGLRuleRefinement refinement : refinements) {
			if (refinement instanceof TGGLRuleRefinementAliased aliasedRefinement)
				name2aliasedRefinement.computeIfAbsent(aliasedRefinement.getName(), k -> new LinkedList<>()).add(aliasedRefinement);
		}

		for (TGGLRuleRefinement refinement : refinements)
			checkNoRuleAliasCollisionsRecursive(name2aliasedRefinement, refinement.getSuperRule());

		for (Entry<String, List<TGGLRuleRefinementAliased>> entry : name2aliasedRefinement.entrySet()) {
			if (entry.getValue().size() <= 1)
				continue;

			for (TGGLRuleRefinementAliased alias : entry.getValue()) {
				error(String.format("Alias '%s' is already defined.", entry.getKey()), alias,
						TGGLPackage.Literals.TGGL_RULE_REFINEMENT_ALIASED__NAME);
			}
		}
	}

	private void checkNoRuleAliasCollisionsRecursive(Map<String, List<TGGLRuleRefinementAliased>> name2aliasedRefinement, TGGRule rule) {
		if (name2aliasedRefinement.containsKey(rule.getName())) {
			List<TGGLRuleRefinementAliased> aliases = name2aliasedRefinement.get(rule.getName());
			for (TGGLRuleRefinementAliased alias : aliases) {
				error(String.format("Alias '%s' must not be the same as its rule or other refined rules.", rule.getName()), alias,
						TGGLPackage.Literals.TGGL_RULE_REFINEMENT_ALIASED__NAME);
			}
		}

		EList<TGGLRuleRefinement> refinements = rule.getRefinements();
		if (refinements == null || refinements.isEmpty())
			return;

		for (TGGLRuleRefinement refinement : refinements) {
			if (refinement instanceof TGGLRuleRefinementAliased aliasedRefinement)
				name2aliasedRefinement.computeIfAbsent(aliasedRefinement.getName(), k -> new LinkedList<>()).add(aliasedRefinement);
		}

		for (TGGLRuleRefinement refinement : refinements)
			checkNoRuleAliasCollisionsRecursive(name2aliasedRefinement, refinement.getSuperRule());
	}

	@Check
	public void checkUniqueNodesNames(TGGRule rule) {
		Map<String, List<EObject>> name2nodes = new HashMap<>();
		fillNodeNameMap(rule, name2nodes);

		// this checks for duplicates in the rule itself
		for (Entry<String, List<EObject>> entry : name2nodes.entrySet()) {
			if (entry.getValue().size() <= 1)
				continue;

			for (EObject duplNode : entry.getValue()) {
				EAttribute nameFeature = duplNode instanceof TGGCorrespondenceNode ? //
						TGGLPackage.Literals.TGG_CORRESPONDENCE_NODE__NAME : //
						SlimGTPackage.Literals.SLIM_RULE_NODE__NAME;

				error(String.format("A node with name '%s' does already exist in this rule.", entry.getKey()), duplNode, nameFeature);
			}
		}

		Map<String, Collection<EObject>> name2refinementNode = new HashMap<>();

		for (TGGLRuleRefinement refinement : rule.getRefinements()) {
			TGGRule superRule = refinement.getSuperRule();
			if (superRule == null)
				continue;
			for (var finalRuleNode : collectAllFinalRuleNodes(superRule))
				name2refinementNode.computeIfAbsent(finalRuleNode.getName(), k -> new LinkedList<>()).add(finalRuleNode);
			for (var finalCorrRuleNode : collectAllFinalCorrRuleNodes(superRule))
				name2refinementNode.computeIfAbsent(finalCorrRuleNode.getName(), k -> new LinkedList<>()).add(finalCorrRuleNode);
		}

		// this checks for naming collisions between this rule and any refining rule
		SetView<String> duplicates = Sets.intersection(name2nodes.keySet(), name2refinementNode.keySet());
		for (String duplNodeName : duplicates) {
			List<EObject> duplRuleNodes = name2nodes.get(duplNodeName);

			for (EObject duplRuleNode : duplRuleNodes) {
				List<String> issueData = new LinkedList<>();
				issueData.add(duplNodeName);
				for (EObject refinementNode : name2refinementNode.get(duplNodeName)) {
					TGGRule refinementRule = SlimGTModelUtil.getContainer(refinementNode, TGGRule.class);
					if (refinementRule == null)
						continue;
					issueData.add(refinementRule.getName());
				}

				EAttribute nameFeature = duplRuleNode instanceof TGGCorrespondenceNode ? //
						TGGLPackage.Literals.TGG_CORRESPONDENCE_NODE__NAME : //
						SlimGTPackage.Literals.SLIM_RULE_NODE__NAME;

				Collection<EObject> refinements = extractRefinements(duplRuleNode);

				// each node in this set is in naming conflict with an equally named node in this rule
				for (EObject conflictNode : name2refinementNode.get(duplNodeName)) {
					// skip if there is a refinement relation
					if (refinements.contains(conflictNode))
						continue;

					error(String.format("A node with name '%s' does already exist in a refined rule.", duplNodeName), duplRuleNode, nameFeature,
							IssueCodes.MISSING_NODE_REFINEMENT, issueData.toArray(new String[] {}));
				}
			}
		}

		for (var superNodeName : name2refinementNode.keySet()) {
			var superNodes = name2refinementNode.get(superNodeName);

			// if a node with this name is already included in this rule, we have handled it in the loop on top
			if (name2nodes.containsKey(superNodeName))
				continue;

			// if there is only one element, then there is no conflict
			if (superNodes.size() == 1)
				continue;

			// if there is more than one element, then we have to ensure uniqueness
			error(String.format(
					"Multiple refinements of this rule contain nodes with the identical name '%s'. To ensure uniqueness, refine at least one of these nodes and assign a different name.",
					superNodeName), rule, TGGLPackage.Literals.TGG_RULE__NAME);
		}
	}

	private Collection<EObject> extractRefinements(EObject node) {
		var container = node.eContainer();
		var refinements = new HashSet<EObject>();
		if (container instanceof SlimRuleNodeContext context)
			refinements.addAll(context.getRefinement().stream().map(r -> r.getNode()).toList());
		else if (container instanceof SlimRuleNodeCreation creation)
			refinements.addAll(creation.getRefinement().stream().map(r -> r.getNode()).toList());
		else if (container instanceof TGGCorrespondenceNodeContext corrContext)
			refinements.addAll(corrContext.getRefinement().stream().map(r -> r.getNode()).toList());
		else if (container instanceof TGGCorrespondenceNodeCreation corrCreation)
			refinements.addAll(corrCreation.getRefinement().stream().map(r -> r.getNode()).toList());
		return refinements;
	}

	private Collection<SlimRuleNode> collectAllFinalRuleNodes(TGGRule rule) {
		return collectAllFinalRuleNodes(rule, new HashSet<>());
	}

	private Collection<SlimRuleNode> collectAllFinalRuleNodes(TGGRule rule, Collection<SlimRuleNode> refinedNodes) {
		var refinedNodesCopy = new HashSet<>(refinedNodes);
		var finalRuleNodes = new HashSet<SlimRuleNode>();

		var nodes = getElements(rule, SlimRuleNode.class);
		for (var node : nodes) {
			var container = node.eContainer();
			Collection<TGGRuleRefinementNode> refinements = null;
			if (container instanceof SlimRuleNodeContext context) {
				refinements = context.getRefinement();
			} else if (container instanceof SlimRuleNodeCreation creation) {
				refinements = creation.getRefinement();
			}

			// if this node has not been refined, it will be part of the final rule
			if (!refinedNodes.contains(node)) {
				finalRuleNodes.add(node);
			}

			// we save all actual refinements as these are the nodes that we want to skip because they can no
			// longer clash
			for (var refinement : refinements) {
				var refinedNode = refinement.getNode();
				refinedNodesCopy.add(refinedNode);
			}
		}

		for (var refinementRule : rule.getRefinements()) {
			var superRule = refinementRule.getSuperRule();
			if (superRule == null)
				continue;
			var newRefinementNodes = collectAllFinalRuleNodes(superRule, refinedNodesCopy);
			finalRuleNodes.addAll(newRefinementNodes);
		}

		return finalRuleNodes;
	}

	private Collection<TGGCorrespondenceNode> collectAllFinalCorrRuleNodes(TGGRule rule) {
		return collectAllFinalCorrRuleNodes(rule, new HashSet<>());
	}

	private Collection<TGGCorrespondenceNode> collectAllFinalCorrRuleNodes(TGGRule rule, Collection<TGGCorrespondenceNode> refinedNodes) {
		var refinedNodesCopy = new HashSet<>(refinedNodes);
		var finalRuleNodes = new HashSet<TGGCorrespondenceNode>();

		var nodes = getElements(rule, TGGCorrespondenceNode.class);
		for (var node : nodes) {
			var container = node.eContainer();
			Collection<TGGLRuleRefinementCorrespondenceNode> refinements = null;
			if (container instanceof TGGCorrespondenceNodeContext context) {
				refinements = context.getRefinement();
			} else if (container instanceof TGGCorrespondenceNodeCreation creation) {
				refinements = creation.getRefinement();
			}

			// if this node has not been refined, it will be part of the final rule
			if (!refinedNodes.contains(node)) {
				finalRuleNodes.add(node);
			}

			// we save all actual refinements as these are the nodes that we want to skip because they can no
			// longer clash
			for (var refinement : refinements) {
				var refinedNode = refinement.getNode();
				refinedNodesCopy.add(refinedNode);
			}
		}

		for (var refinementRule : rule.getRefinements()) {
			var superRule = refinementRule.getSuperRule();
			if (superRule == null)
				continue;
			var newRefinementNodes = collectAllFinalCorrRuleNodes(superRule, refinedNodesCopy);
			finalRuleNodes.addAll(newRefinementNodes);
		}

		return finalRuleNodes;
	}

	private void fillNodeNameMap(TGGRule rule, Map<String, List<EObject>> name2nodes) {
		TGGDomainRule srcDomain = rule.getSourceRule();
		if (srcDomain != null)
			fillNodeNameMap(srcDomain, name2nodes);

		TGGDomainRule trgDomain = rule.getTargetRule();
		if (trgDomain != null)
			fillNodeNameMap(trgDomain, name2nodes);

		TGGCorrRule corrDomain = rule.getCorrRule();
		if (corrDomain != null)
			fillNodeNameMapCorr(corrDomain, name2nodes);
	}

	private void fillNodeNameMap(TGGDomainRule domain, Map<String, List<EObject>> name2nodes) {
		for (SlimRuleNodeContext contextNode : domain.getContextNodes()) {
			SlimRuleNode node = (SlimRuleNode) contextNode.getContext();
			if (node == null)
				continue;
			name2nodes.computeIfAbsent(node.getName(), k -> new LinkedList<>()).add(node);
		}
		for (SlimRuleNodeCreation createNode : domain.getCreatedNodes()) {
			SlimRuleNode node = (SlimRuleNode) createNode.getCreation();
			if (node == null)
				continue;
			name2nodes.computeIfAbsent(node.getName(), k -> new LinkedList<>()).add(node);
		}
	}

	private void fillNodeNameMapCorr(TGGCorrRule domain, Map<String, List<EObject>> name2nodes) {
		for (TGGCorrespondenceNodeContext contextCorr : domain.getContextCorrespondenceNodes()) {
			TGGCorrespondenceNode node = contextCorr.getContext();
			if (node == null)
				continue;
			name2nodes.computeIfAbsent(node.getName(), k -> new LinkedList<>()).add(node);
		}
		for (TGGCorrespondenceNodeCreation createCorr : domain.getCreatedCorrespondenceNodes()) {
			TGGCorrespondenceNode node = createCorr.getCreation();
			if (node == null)
				continue;
			name2nodes.computeIfAbsent(node.getName(), k -> new LinkedList<>()).add(node);
		}
	}

	@Check
	public void checkRefinedNodeBindingMatches(SlimRuleNodeContext contextNode) {
		for (var refinement : contextNode.getRefinement()) {
			SlimRuleNode refinedNode = refinement.getNode();
			if (refinedNode == null)
				continue;

			if (refinedNode.eContainer() instanceof SlimRuleNodeContext)
				continue;

			TGGDomainRule domainRule = SlimGTModelUtil.getContainer(contextNode, TGGDomainRule.class);
			error("The refining node must be of the same binding type as the refined node.", domainRule,
					TGGLPackage.Literals.TGG_DOMAIN_RULE__CONTEXT_NODES, IssueCodes.INCORRECT_BINDING_NODE_REFINED_CONTEXT);
		}

	}

	@Check
	public void checkRefinedNodeBindingMatches(SlimRuleNodeCreation createNode) {
		for (var refinement : createNode.getRefinement()) {
			SlimRuleNode refinedNode = refinement.getNode();
			if (refinedNode == null)
				continue;

			if (refinedNode.eContainer() instanceof SlimRuleNodeCreation)
				continue;

			TGGDomainRule domainRule = SlimGTModelUtil.getContainer(createNode, TGGDomainRule.class);
			error("The refining node must be of the same binding type as the refined node.", domainRule,
					TGGLPackage.Literals.TGG_DOMAIN_RULE__CREATED_NODES, IssueCodes.INCORRECT_BINDING_NODE_REFINED_CREATE);
		}

	}

	@Check
	public void checkRefinedNodeBindingMatches(TGGCorrespondenceNodeContext contextNode) {
		for (var refinement : contextNode.getRefinement()) {
			TGGCorrespondenceNode refinedNode = refinement.getNode();
			if (refinedNode == null)
				continue;

			if (refinedNode.eContainer() instanceof TGGCorrespondenceNodeContext)
				continue;

			TGGCorrRule corrRule = SlimGTModelUtil.getContainer(contextNode, TGGCorrRule.class);
			error("The refining node must be of the same binding type as the refined node.", corrRule,
					TGGLPackage.Literals.TGG_CORR_RULE__CONTEXT_CORRESPONDENCE_NODES, IssueCodes.INCORRECT_BINDING_NODE_REFINED_CONTEXT);
		}
	}

	@Check
	public void checkRefinedNodeBindingMatches(TGGCorrespondenceNodeCreation createNode) {
		for (var refinement : createNode.getRefinement()) {
			TGGCorrespondenceNode refinedNode = refinement.getNode();
			if (refinedNode == null)
				continue;

			if (refinedNode.eContainer() instanceof TGGCorrespondenceNodeCreation)
				continue;

			TGGCorrRule corrRule = SlimGTModelUtil.getContainer(createNode, TGGCorrRule.class);
			error("The refining node must be of the same binding type as the refined node.", corrRule,
					TGGLPackage.Literals.TGG_CORR_RULE__CREATED_CORRESPONDENCE_NODES, IssueCodes.INCORRECT_BINDING_NODE_REFINED_CREATE);
		}
	}

	@Check
	public void checkOnlyOneSingleEdge(SlimRuleNode node) {
		List<SlimRuleEdge> singleEdges = new LinkedList<>();
		collectSingleEdges(node, singleEdges);

		Map<EReference, List<SlimRuleEdge>> ref2singleEdge = new HashMap<>();
		for (SlimRuleEdge singleEdge : singleEdges)
			ref2singleEdge.computeIfAbsent(singleEdge.getType(), k -> new LinkedList<>()).add(singleEdge);

//		for (Entry<EReference, List<SlimRuleEdge>> entry : ref2singleEdge.entrySet()) {
//			if (entry.getValue().size() > 1) {
//				for (SlimRuleEdge edge : entry.getValue()) {
//					if (!Objects.equals(edge.eResource(), node.eResource()))
//						continue;
//
//					error(String.format("Edge '%s' has a max. cardinality of 1 and, hence, cannot be set more than once.", entry.getKey().getName()),
//							edge, SlimGTPackage.Literals.SLIM_RULE_EDGE__TYPE);
//				}
//			}
//		}
	}

	private void collectSingleEdges(SlimRuleNode node, List<SlimRuleEdge> singleEdges) {
		singleEdges.addAll(node.getContextEdges().stream() //
				.filter(e -> e.getContext() != null) //
				.map(e -> e.getContext()) //
				.filter(e -> !e.getType().isMany()) //
				.toList());

		singleEdges.addAll(node.getCreatedEdges().stream() //
				.filter(e -> e.getCreation() != null) //
				.map(e -> e.getCreation()) //
				.filter(e -> !e.getType().isMany()) //
				.toList());

		EObject container = node.eContainer();
		Collection<TGGRuleRefinementNode> nodeRefinements = null;
		if (container instanceof SlimRuleNodeContext context)
			nodeRefinements = context.getRefinement();
		else if (container instanceof SlimRuleNodeCreation creation)
			nodeRefinements = creation.getRefinement();

		for (TGGRuleRefinementNode refinementNode : nodeRefinements)
			collectSingleEdges(refinementNode.getNode(), singleEdges);
	}

	@Check
	public void checkOnlyOneEdgeOfTypeBetweenTwoNodes(SlimRuleNode node) {
		List<SlimRuleEdge> edges = new LinkedList<>();
		collectManyEdges(node, edges);

		Map<EReference, List<SlimRuleEdge>> ref2edge = new HashMap<>();
		for (SlimRuleEdge edge : edges)
			ref2edge.computeIfAbsent(edge.getType(), k -> new LinkedList<>()).add(edge);

		for (Entry<EReference, List<SlimRuleEdge>> entry : ref2edge.entrySet()) {
			if (entry.getValue().size() <= 1)
				continue;

			Map<SlimRuleNode, List<SlimRuleEdge>> target2edge = new HashMap<>();
			for (SlimRuleEdge edge : entry.getValue())
				target2edge.computeIfAbsent((SlimRuleNode) edge.getTarget(), k -> new LinkedList<>()).add(edge);

			for (Entry<SlimRuleNode, List<SlimRuleEdge>> e : target2edge.entrySet()) {
				if (e.getValue().size() > 1) {
					for (SlimRuleEdge edge : e.getValue()) {
						if (!Objects.equals(edge.eResource(), node.eResource()))
							continue;

						error(String.format("Edge '%s' is connected to the same node more than once.", edge.getType().getName()), edge,
								SlimGTPackage.Literals.SLIM_RULE_EDGE__TYPE);
					}
				}
			}
		}
	}

	private void collectManyEdges(SlimRuleNode node, List<SlimRuleEdge> manyEdges) {
		manyEdges.addAll(node.getContextEdges().stream() //
				.filter(e -> e.getContext() != null) //
				.map(e -> e.getContext()) //
				.filter(e -> e.getType().isMany()) //
				.toList());

		manyEdges.addAll(node.getCreatedEdges().stream() //
				.filter(e -> e.getCreation() != null) //
				.map(e -> e.getCreation()) //
				.filter(e -> e.getType().isMany()) //
				.toList());

		EObject container = node.eContainer();
		Collection<TGGRuleRefinementNode> nodeRefinements = null;
		if (container instanceof SlimRuleNodeContext context)
			nodeRefinements = context.getRefinement();
		else if (container instanceof SlimRuleNodeCreation creation)
			nodeRefinements = creation.getRefinement();

		for (TGGRuleRefinementNode refinementNode : nodeRefinements)
			collectManyEdges(refinementNode.getNode(), manyEdges);
	}

	@Check
	public void checkOnlyOneAttributeAssignment(SlimRuleNode node) {
		Map<EAttribute, List<SlimRuleAttributeAssignment>> type2attrAssignments = new HashMap<>();
		for (SlimRuleAttributeAssignment attrAssignment : node.getAssignments()) {
			EAttribute type = attrAssignment.getType();
			type2attrAssignments.computeIfAbsent(type, k -> new LinkedList<>()).add(attrAssignment);
		}

		for (Entry<EAttribute, List<SlimRuleAttributeAssignment>> entry : type2attrAssignments.entrySet()) {
			if (entry.getValue().size() > 1) {
				for (SlimRuleAttributeAssignment attrAssignment : entry.getValue()) {
					error(String.format("Attribute '%s' must not be assigned more than once.", entry.getKey().getName()), attrAssignment,
							SlimGTPackage.Literals.SLIM_RULE_ATTRIBUTE_ASSIGNMENT__TYPE);
				}
			}
		}
	}

	@Check
	public void checkAttributeAssignmentNodeAttributeIsSpecified(SlimRuleAttributeAssignment attrAssignment) {
		ValueExpression valueExpr = attrAssignment.getValue();
		if (valueExpr == null || !(valueExpr instanceof ExpressionOperand exprOp))
			return;

		EObject operand = exprOp.getOperand();
		if (operand == null || !(operand instanceof NodeAttributeExpression nodeAttrExpr))
			return;

		if (nodeAttrExpr.getFeature() == null) {
			error("A reference to an attribute is missing for this attribute assignment.", attrAssignment,
					SlimGTPackage.Literals.SLIM_RULE_ATTRIBUTE_ASSIGNMENT__VALUE);
			;
		}
	}

	@Check
	public void checkAttributeAssignmentWithRefToItselfForbidden(SlimRuleAttributeAssignment attrAssignment) {
		ValueExpression valueExpr = attrAssignment.getValue();
		if (valueExpr == null || !(valueExpr instanceof ExpressionOperand exprOp))
			return;

		EObject operand = exprOp.getOperand();
		if (operand == null || !(operand instanceof NodeAttributeExpression nodeAttrExpr))
			return;

		NodeExpression nodeExpr = nodeAttrExpr.getNodeExpression();
		if (nodeExpr == null)
			return;

		SlimRuleNode parentNode = SlimGTModelUtil.getContainer(attrAssignment, SlimRuleNode.class);
		if (nodeExpr.getNode().equals(parentNode)) {
			error("Attribute assignments which reference its own node are forbidden.", nodeAttrExpr,
					SlimGTPackage.Literals.NODE_ATTRIBUTE_EXPRESSION__NODE_EXPRESSION);
		}
	}

	@Check
	public void checkCSPCorrectNumberOfArguments(AttributeCondition attrCond) {
		AttributeConditionDefinition def = attrCond.getName();
		if (def == null)
			return;

		int expNumber = def.getParams().size();
		int actNumber = attrCond.getValues().size();
		if (expNumber != actNumber) {
			error(String.format("The number of parameters does not match the definition of attribute condition '%s'. Expected: %s, actual: %s.",
					def.getName(), expNumber, actNumber), attrCond, TGGLPackage.Literals.ATTRIBUTE_CONDITION__NAME);
		}
	}

	@Check
	public void checkCSPCorrectArgumentTypes(TGGRule rule) {
		Map<String, EDataType> locVar2TypeCache = new HashMap<>();

		List<AttributeCondition> attrConds = new LinkedList<>();
		collectAttributeConditions(rule, attrConds);

		for (AttributeCondition attrCond : attrConds)
			checkCSPCorrectArgumentTypes(attrCond, locVar2TypeCache);
	}

	private void collectAttributeConditions(TGGRule currentRule, List<AttributeCondition> attrConds) {
		attrConds.addAll(currentRule.getAttrConditions());

		for (TGGLRuleRefinement refinement : currentRule.getRefinements()) {
			TGGRule superRule = refinement.getSuperRule();
			if (superRule == null)
				continue;

			collectAttributeConditions(superRule, attrConds);
		}
	}

	private void checkCSPCorrectArgumentTypes(AttributeCondition attrCond, Map<String, EDataType> locVar2TypeCache) {
		AttributeConditionDefinition def = attrCond.getName();
		if (def == null)
			return;

		if (def.getParams().size() != attrCond.getValues().size())
			return;

		for (int i = 0; i < def.getParams().size(); i++) {
			SlimParameter defParam = def.getParams().get(i);
			EObject value = attrCond.getValues().get(i);

			EDataType dataType = null;

			if (value instanceof LocalVariable locVar) {
				if (locVar2TypeCache.containsKey(locVar.getName())) {
					dataType = locVar2TypeCache.get(locVar.getName());
				} else {
					locVar2TypeCache.put(locVar.getName(), defParam.getType());
					continue;
				}
			} else if (value instanceof ExpressionOperand exprOp) {
				EObject op = exprOp.getOperand();
				if (op instanceof NodeAttributeExpression nodeAttrExpr) {
					dataType = nodeAttrExpr.getFeature().getEAttributeType();
				} else if (op instanceof ArithmeticLiteral arithLit) {
					EObject litVal = arithLit.getValue();
					if (litVal instanceof DoubleLiteral)
						dataType = EcorePackage.Literals.EDOUBLE;
					else if (litVal instanceof IntegerLiteral)
						dataType = EcorePackage.Literals.EINT;
					else if (litVal instanceof StringLiteral)
						dataType = EcorePackage.Literals.ESTRING;
					else if (litVal instanceof BooleanLiteral)
						dataType = EcorePackage.Literals.EBOOLEAN;
					else
						continue;
				} else if (op instanceof EnumExpression enumExpr) {
					dataType = enumExpr.getLiteral().getEEnum();
				} else if (op instanceof Constant constant) {
					String constLit = constant.getValue().getLiteral();
					switch (constLit) {
						case "e", "pi" -> {
							dataType = EcorePackage.Literals.EDOUBLE;
						}
						case "null" -> {
							continue;
						}
						default -> throw new IllegalArgumentException("Unexpected value: " + constLit);
					}
				} else {
					continue;
				}
			} else {
				continue;
			}

			if (dataType != null && !dataType.getInstanceClassName().equals(defParam.getType().getInstanceClassName())) {
				error(String.format("Argument %s of CSP '%s' does not match its parameter type.", i + 1, attrCond.getName().getName()), attrCond,
						TGGLPackage.Literals.ATTRIBUTE_CONDITION__VALUES, i);
			}
		}
	}

	@Check
	public void checkDoubleImportsForbidden(EditorFile editorFile) {
		EList<Import> imports = editorFile.getImports();

		if (imports == null || imports.size() <= 1)
			return;

		Map<String, List<Import>> name2imports = new HashMap<>();
		for (Import imp : imports)
			name2imports.computeIfAbsent(imp.getName(), k -> new LinkedList<>()).add(imp);

		for (Entry<String, List<Import>> entry : name2imports.entrySet()) {
			if (entry.getValue().size() <= 1)
				continue;

			for (Import imp : entry.getValue())
				error(String.format("Ecore file '%s' must not be imported more than once.", imp.getName()), imp, SlimGTPackage.Literals.IMPORT__NAME);
		}
	}

	@Check
	public void checkImportsOnlyInSchemaFile(EditorFile editorFile) {
		if (editorFile.getSchema() != null)
			return;

		for (int i = 0; i < editorFile.getImports().size(); i++) {
			error("Imports must only be located in schema file.", editorFile, SlimGTPackage.Literals.EDITOR_FILE__IMPORTS, i,
					IssueCodes.IMPORT_NOT_IN_SCHEMA_FILE);
		}
	}

	@Check
	public void checkOnlyOneSchemaInProject(EditorFile editorFile) {
		Collection<EditorFile> allFiles = TGGLWorkspaceUtil.getAllFilesInScope(editorFile);
		long numberOfSchemaFiles = allFiles.stream() //
				.filter(f -> f.getSchema() != null) //
				.count();

		if (numberOfSchemaFiles > 1) {
			error("There must be only one file with a schema in a project.", TGGLPackage.Literals.EDITOR_FILE__SCHEMA);
		}
	}

	@Check
	public void checkSupportPatternNotAbstract(SlimRuleInvocation invocation) {
		if (invocation.getSupportPattern() == null)
			return;

		if (invocation.getSupportPattern() instanceof SlimRule slimRule && slimRule.isAbstract()) {
			error("Invoked patterns must not be abstract.", SlimGTPackage.Literals.SLIM_RULE_INVOCATION__SUPPORT_PATTERN);
		}
	}

	@Check
	public void checkSupportPatternNoCycle(SlimRuleInvocation invocation) {
		if (invocation.getSupportPattern() == null)
			return;

		Set<SlimRule> traversedRules = new HashSet<>();
		SlimRule currentPattern = SlimGTModelUtil.getContainer(invocation, SlimRule.class);
		if (currentPattern != null)
			traversedRules.add(currentPattern);

		if (invocationHierarchyHasCycle(invocation, traversedRules)) {
			error(String.format("Invoked pattern '%s' leads to an invocation cycle, which is not allowed.",
					((SlimRule) invocation.getSupportPattern()).getName()), SlimGTPackage.Literals.SLIM_RULE_INVOCATION__SUPPORT_PATTERN);
		}
	}

	private boolean invocationHierarchyHasCycle(SlimRuleInvocation ruleInvocation, Set<SlimRule> traversedRules) {
		if (ruleInvocation.getSupportPattern() == null)
			return false;

		SlimRule invokee = (SlimRule) ruleInvocation.getSupportPattern();

		if (traversedRules.contains(invokee))
			return true;

		traversedRules.add(invokee);

		// Check for plain invocations
		if (invokee.getInvocations() == null)
			return false;

		for (SlimRuleInvocation other : invokee.getInvocations()) {
			if (invocationHierarchyHasCycle(other, traversedRules)) {
				return true;
			}
		}

		return false;
	}

	class Vertex {
		final Set<Vertex> targets;

		Vertex() {
			targets = new HashSet<>();
		}
	}

	private Collection<Vertex> convertPatternToVertexSet(SlimRule pattern) {
		var allNodes2Vertices = new HashMap<EObject, Vertex>();

		Collection<SlimRuleNode> nodes = getElements(pattern, SlimRuleNode.class);
		for (SlimRuleNode node : nodes)
			allNodes2Vertices.put(node, new Vertex());

		// Update edges of all vertices
		for (SlimRuleNode srcNode : nodes) {
			Vertex srcVertex = allNodes2Vertices.get(srcNode);
			for (var contextEdge : srcNode.getContextEdges()) {
				SlimRuleNode trgNode = (SlimRuleNode) contextEdge.getContext().getTarget();
				Vertex trgVertex = allNodes2Vertices.get(trgNode);
				srcVertex.targets.add(trgVertex);
			}
		}
		
		return allNodes2Vertices.values();
	}

	private Collection<Vertex> convertRuleToVertexSet(TGGRule rule) {
		var allNodes2Vertices = new HashMap<EObject, Vertex>();

		Collection<SlimRuleNode> nodes = getElements(rule, SlimRuleNode.class);
		for (var node : nodes)
			allNodes2Vertices.put(node, new Vertex());

		Collection<TGGCorrespondenceNode> corrNodes = getElements(rule, TGGCorrespondenceNode.class);
		for (var corrNode : corrNodes)
			allNodes2Vertices.put(corrNode, new Vertex());

		// Update edges of all vertices
		for (SlimRuleNode srcNode : nodes) {
			Vertex srcVertex = allNodes2Vertices.get(srcNode);
			for (var contextEdge : srcNode.getContextEdges()) {
				SlimRuleNode trgNode = (SlimRuleNode) contextEdge.getContext().getTarget();
				Vertex trgVertex = allNodes2Vertices.get(trgNode);
				srcVertex.targets.add(trgVertex);
			}
			for (var createEdge : srcNode.getCreatedEdges()) {
				SlimRuleNode trgNode = (SlimRuleNode) createEdge.getCreation().getTarget();
				Vertex trgVertex = allNodes2Vertices.get(trgNode);
				srcVertex.targets.add(trgVertex);
			}
		}
		for (TGGCorrespondenceNode corrNode : corrNodes) {
			Vertex corrVertex = allNodes2Vertices.get(corrNode);

			SlimRuleNode srcNode = corrNode.getSource();
			Vertex srcVertex = allNodes2Vertices.get(srcNode);
			corrVertex.targets.add(srcVertex);

			SlimRuleNode trgNode = corrNode.getTarget();
			Vertex trgVertex = allNodes2Vertices.get(trgNode);
			corrVertex.targets.add(trgVertex);
		}

		return allNodes2Vertices.values();
	}

	private Set<Set<Vertex>> groupVerticesIntoDisjointGraphs(Collection<Vertex> allVertices) {
		Map<Vertex, Set<Vertex>> vertex2vertexSet = allVertices.stream() //
				.collect(Collectors.toMap(k -> k, k -> {
					Set<Vertex> vertices = new HashSet<>();
					vertices.add(k);
					return vertices;
				}));

		List<Vertex> vertices = new LinkedList<>(vertex2vertexSet.keySet());
		for (var srcVertex : vertices) {
			for (var trgVertex : srcVertex.targets) {
				Set<Vertex> srcVertexSet = vertex2vertexSet.get(srcVertex);
				Set<Vertex> trgVertexSet = vertex2vertexSet.get(trgVertex);
				if (!srcVertexSet.equals(trgVertexSet)) {
					Set<Vertex> union = new HashSet<>(Sets.union(srcVertexSet, trgVertexSet));
					for (Vertex vertex : union)
						vertex2vertexSet.put(vertex, union);
				}
			}
		}
		return new HashSet<>(vertex2vertexSet.values());
	}

	@Check
	public void checkDisjointPatternNotAbstract(SlimRule pattern) {
		if (pattern.isAbstract())
			return;

		var modelFlattener = new TGGLModelFlattener();
		SlimRule flattenedPattern = modelFlattener.flatten(pattern);

		Collection<Vertex> vertices = convertPatternToVertexSet(flattenedPattern);
		Set<Set<Vertex>> disjointVertices = groupVerticesIntoDisjointGraphs(vertices);
		if (disjointVertices.size() > 1) {
			warning("This pattern is disjoint and could be computationally expensive.", TGGLPackage.Literals.SLIM_RULE__NAME);
		}
	}

	@Check
	public void checkDisjointRuleNotAbstract(TGGRule rule) {
		if (rule.isAbstract())
			return;

		var modelFlattener = new TGGLModelFlattener();
		TGGRule flattenedRule = modelFlattener.flatten(rule);

		Collection<Vertex> vertices = convertRuleToVertexSet(flattenedRule);
		Set<Set<Vertex>> disjointVertices = groupVerticesIntoDisjointGraphs(vertices);
		if (disjointVertices.size() > 1) {
			warning("This rule is disjoint and could be computationally expensive.", TGGLPackage.Literals.TGG_RULE__NAME);
		}
	}

}
