grammar org.emoflon.ibex.common.slimgt.SlimGT with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate slimGT "http://www.emoflon.org/ibex/common/slimgt/SlimGT"

EditorFile:
	imports += Import
;

Import:
	'#import' name = STRING
;

SlimRule:
	(contextNodes += SlimRuleNodeContext |
	createdNodes += SlimRuleNodeCreation |
	atrConditions += SlimRuleAttributeCondition)
;

SlimRuleNodeContext:
	(local?='local')? context = SlimRuleNode
;

SlimRuleNodeCreation: 
	'++' creation = SlimRuleNode
;

SlimRuleNode:
	name = ID ':' type=[ecore::EClass] ('{'
		(contextEdges += SlimRuleEdgeContext |
		createdEdges += SlimRuleEdgeCreation |
		assignments += SlimRuleAttributeAssignment)
	'}')?
;

SlimRuleEdgeContext:
	context = SlimRuleEdge
;

SlimRuleEdgeCreation:
	'++' creation = SlimRuleSimpleEdge
;

SlimRuleEdge:
	SlimRuleSimpleEdge //| SlimRuleTransitiveEdge
;

SlimRuleSimpleEdge returns SlimRuleEdge: {SlimRuleSimpleEdge}
	'-' type=[ecore::EReference] '->' target=[SlimRuleNode|ID]
;

SlimRuleTransitiveEdge returns SlimRuleEdge: {SlimRuleTransitiveEdge}
	'~' type=[ecore::EReference] '~>' target=[SlimRuleNode|ID]
;

SlimRuleAttributeAssignment:
	'.' type=[ecore::EAttribute] ':=' value=ValueExpression
;

SlimRuleAttributeCondition:
	'#' lhs=ValueExpression operator=RelationalOperator rhs=ValueExpression
;

enum RelationalOperator:
  GREATER='>' |
  GREATER_OR_EQUAL='>=' |
  EQUAL='==' |
  UNEQUAL='!=' |
  SMALLER_OR_EQUAL='<=' |
  SMALLER='<'
;

SlimParameter:
  name=ID ':' (type = [ecore::EDataType | QualifiedName])
;

SlimRuleNodeMapping:
	srcNode = [SlimRuleNode|ID] '=' trgNode = [SlimRuleNode|ID]
;

SlimRuleNodeMappings:
	'['mappings+=SlimRuleNodeMapping (',' mappings+=SlimRuleNodeMapping)*']'
;

SlimRuleInvocation :
	type=SlimRuleInvocationType supportPattern=[SlimRule|ID] (mappings=SlimRuleNodeMappings)?
;

enum SlimRuleInvocationType :
	POSITIVE = 'enforce' | NEGATIVE = 'forbid'
;

ValueExpression:
	ArithmeticExpression
;

ArithmeticExpression:
	SumArithmeticExpression
;

SumArithmeticExpression returns ArithmeticExpression:
	ProductArithmeticExpression({SumArithmeticExpression.left = current} operator=SumOperator right=ProductArithmeticExpression)* 
;

ProductArithmeticExpression returns ArithmeticExpression:
	ExpArithmeticExpression({ProductArithmeticExpression.left = current} operator=ProductOperator right=ExpArithmeticExpression)*
;

ExpArithmeticExpression returns ArithmeticExpression:
	(UnaryArithmeticExpression | StochasticArithmeticExpression | MinMaxArithmeticExpression)
	({ExpArithmeticExpression.left = current} operator=ExpOperator right=(UnaryArithmeticExpression | StochasticArithmeticExpression | MinMaxArithmeticExpression))*
;

StochasticArithmeticExpression returns ArithmeticExpression:
	{StochasticArithmeticExpression} distribution = StochasticDistribution '(' mean = ArithmeticExpression (hasSd ?= "," sd = ArithmeticExpression)? ')'
;

MinMaxArithmeticExpression returns ArithmeticExpression:
	{MinMaxArithmeticExpression} minMaxOperator = MinMaxOperator '(' left = ArithmeticExpression "," right = ArithmeticExpression ')'
;

UnaryArithmeticExpression returns ArithmeticExpression: {UnaryArithmeticExpression}
	operator=UnaryOperator '(' operand=BracketExpression ')' | BracketExpression
;

BracketExpression returns ArithmeticExpression: {BracketExpression}
	'(' operand=ArithmeticExpression ')' | ExpressionOperand
;

ExpressionOperand:
	operand = (NodeAttributeExpression | CountExpression | ArithmeticLiteral | EnumExpression | Constant)
;

NodeAttributeExpression:
	node = [SlimRuleNode|ID] '.' feature = [ecore::EAttribute]
;

CountExpression:
	'count' '(' invokedPatten = [SlimRule|ID] ')' (mappings=SlimRuleNodeMappings)?
;

EnumExpression:
 	'enum::' literal=[ecore::EEnumLiteral]
;

ArithmeticLiteral:
	value = (DoubleLiteral | IntegerLiteral | StringLiteral | BooleanLiteral)
;

Constant:
	value = ConstantLiteral
;

enum ConstantLiteral:
	PI 	= 	'pi' 	|
	E 	= 	'e' 	|
	NULL= 	'null'
;

enum ProductOperator:
	MULT=	'*' 	|
 	DIV	=	'/'	 	|
 	MOD	=	'%'
;

enum ExpOperator:
 	POW = 	'pow'	|
 	LOG = 	'log'
;

enum SumOperator:
	PLUS =	'+' 	|
	MINUS=	'-' 	
;

enum StochasticDistribution:
	NORMAL 		= 	"N" 	| 
	UNIFORM 	= 	"U" 	| 
	EXPONENTIAL = 	"Exp"
;	

enum MinMaxOperator:
	MAX	=	'max' 	|
	MIN	=	'min' 	
;

enum UnaryOperator:
	NEG	=	'-'		|
	ABS	=	'abs'	|
	SQRT=	'sqrt' 	|
	SIN	=	'sin'	|
	COS	=	'cos'	|
	TAN = 	'tan'
;

QualifiedName returns ecore::EString:
	ID ('.' ID)*
;

DoubleLiteral:
	value = Double
;

IntegerLiteral:
	value = Integer
;

StringLiteral:
	value = STRING
;

BooleanLiteral:
	value = Boolean
;

Double returns ecore::EDouble:
	('-')?INT '.' INT
;

Integer returns ecore::EInt:
	(('-')? INT)
;

@Override
terminal INT returns ecore::EInt:
	'0'..'9' ('0'..'9')*
;

@Override
terminal STRING returns ecore::EString:
	'"' ( '""' | !('"') )* '"'
;

Boolean returns ecore::EBoolean:
	TRUE | FALSE
;

terminal TRUE returns ecore::EBoolean:
	'true'
;

terminal FALSE returns ecore::EBoolean:
	'false'
;
